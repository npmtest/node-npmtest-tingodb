{"/home/travis/build/npmtest/node-npmtest-tingodb/test.js":"/* istanbul instrument in package npmtest_tingodb */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-tingodb/lib.npmtest_tingodb.js":"/* istanbul instrument in package npmtest_tingodb */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_tingodb = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_tingodb = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-tingodb/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-tingodb && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_tingodb */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_tingodb\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_tingodb.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_tingodb.rollup.js'] =\n            local.assetsDict['/assets.npmtest_tingodb.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_tingodb.__dirname + '/lib.npmtest_tingodb.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-tingodb/node_modules/tingodb/lib/main.js":"module.exports = function (opts) {\n\topts = opts || {};\n\tvar db = require('./tdb.js');\n\tvar ObjectID = opts.nativeObjectID ? (require(\"bson\").ObjectID || require(\"mongodb\").ObjectID) : require(\"./ObjectId\");\n\tif (opts.nativeObjectID) {\n\t\tObjectID.prototype.valueOf = function () {\n\t\t\treturn this.toString();\n\t\t}\n\t}\n\tfunction gdb (path,optsLocal) {\n\t\tgdb.superclass.constructor.call(this, path, optsLocal, opts);\n\t\tthis.ObjectID = ObjectID;\n\t\tthis.Code = require('./tcode.js').Code;\n\t\tthis.Binary = require('./tbinary.js').Binary;\n\t\tthis.Finder = require(\"./finder\")(this);\n\t}\n\tvar F = function() { }\n    F.prototype = db.prototype\n    gdb.prototype = new F()\n    gdb.prototype.constructor = gdb\n    gdb.superclass = db.prototype\n\treturn {\n\t\tDb:gdb,\n\t\tCollection:require('./tcoll.js'),\n\t\tCode:require('./tcode.js').Code,\n\t\tBinary:require('./tbinary.js').Binary,\n\t\tObjectID:ObjectID\n\t}\n}\n","/home/travis/build/npmtest/node-npmtest-tingodb/node_modules/tingodb/lib/db.js":"function tdb() {}\n\nmodule.exports = tdb;\n\ntdb.prototype.init = function (path, options, cb) {\n\tthis._path = path;\n\tcb(null);\n};\n","/home/travis/build/npmtest/node-npmtest-tingodb/node_modules/tingodb/lib/finder.js":"var _ = require('lodash');\n\nvar tdb = null;\nvar expo = {};\nmodule.exports = function (tdb_) {\n\ttdb=tdb_;\n\treturn expo;\n};\n\nvar ops = {\n\t$range : function () {\n\t\tthis.op = \"$range\";\n\t\tthis.dump = function () {\n\t\t\treturn this._args[0].dump() +\" in range (\" +this._args[1].dump()+\",\"+this._args[2].dump()+\",\"+this._args[3].dump()+\",\"+this._args[4].dump()+\")\";\n\t\t},\n\t\tthis._index = function (index) {\n\t\t\tif (index.order > 0) return index.range(this._args[1]._get(), this._args[2]._get(), this._args[3]._get(), this._args[4]._get());\n\t\t\telse return index.range(this._args[2]._get(), this._args[1]._get(), this._args[4]._get(), this._args[3]._get());\n\t\t}\n\t},\n\n\t$lt : function () {\n\t\tthis.op = \"$lt\";\n\t\tthis._index = function (index) {\n\t\t\tif (index.order > 0) return index.range(null, this._args[1]._get(), false, true);\n\t\t\telse return index.range(this._args[1]._get(), null, true, false);\n\t\t};\n\t\tthis._ex = function (f) {\n\t\t\tif (this.fields()[f]!=null)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tthis.dump = function () {\n\t\t\treturn this._args[0].dump() +\" < \" +this._args[1].dump()\n\t\t}\n\t\tthis.native = function () {\n\t\t\treturn this._args[0].native() +\" < \" +this._args[1].native()\n\t\t}\n\t\tthis.native3 = function () {\n\t\t\tvar s = \"(function () {\\n\";\n\t\t\ts+= \"var v = \"+this._args[0].native3()+\"\\n\";\n\t\t\ts+= \"if (!v) return false;\\n\";\n\t\t\ts+= \"for (var i=0; i<v.length; i++ ) {\\n\";\n\t\t\ts+= \"if (v[i]<\"+ this._args[1].native3()+\") return true;\\n\"\n\t\t\ts+= \"}\\nreturn false;})()\";\n\t\t\treturn s;\n\t\t}\n\t},\n\t$lte : function () {\n\t\tthis.op = \"$lte\";\n\t\tthis._index = function (index) {\n\t\t\tif (index.order > 0) return index.range(null, this._args[1]._get(), false, false);\n\t\t\telse return index.range(this._args[1]._get(), null, false, false);\n\t\t};\n\t\tthis._ex = function (f) {\n\t\t\tif (this.fields()[f]!=null)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tthis.dump = function () {\n\t\t\treturn this._args[0].dump() +\" <= \" +this._args[1].dump()\n\t\t}\n\t\tthis.native = function () {\n\t\t\treturn this._args[0].native() +\" <= \" +this._args[1].native()\n\t\t}\n\t\tthis.native3 = function () {\n\t\t\tvar s = \"(function () {\\n\";\n\t\t\ts+= \"var v = \"+this._args[0].native3()+\"\\n\";\n\t\t\ts+= \"if (!v) return false;\\n\";\n\t\t\ts+= \"for (var i=0; i<v.length; i++ ) {\\n\";\n\t\t\ts+= \"if (v[i]<=\"+ this._args[1].native3()+\") return true;\\n\"\n\t\t\ts+= \"}\\nreturn false;})()\";\n\t\t\treturn s;\n\t\t}\n\t},\n\t$gt : function () {\n\t\tthis.op = \"$gt\";\n\t\tthis._index = function (index) {\n\t\t\tif (index.order > 0) return index.range(this._args[1]._get(), null, true, false);\n\t\t\telse return index.range(null, this._args[1]._get(), false, true);\n\t\t};\n\t\tthis._ex = function (f) {\n\t\t\tif (this.fields()[f]!=null)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tthis.dump = function () {\n\t\t\treturn this._args[0].dump() +\" > \" + this._args[1].dump()\n\t\t}\n\t\tthis.native = function () {\n\t\t\treturn this._args[0].native() +\" > \" +this._args[1].native()\n\t\t}\n\t\tthis.native3 = function () {\n\t\t\tvar s = \"(function () {\\n\";\n\t\t\ts+= \"var v = \"+this._args[0].native3()+\"\\n\";\n\t\t\ts+= \"if (!v) return false;\\n\";\n\t\t\ts+= \"for (var i=0; i<v.length; i++ ) {\\n\";\n\t\t\ts+= \"if (v[i]>\"+ this._args[1].native3()+\") return true;\\n\"\n\t\t\ts+= \"}\\nreturn false;})()\";\n\t\t\treturn s;\n\t\t}\n\t},\n\t$gte : function () {\n\t\tthis.op = \"$gte\";\n\t\tthis._get = function (obj) {\n\t\t\treturn this._args[0]._get(obj) >= this._args[1]._get(obj);\n\t\t}\n\t\tthis._index = function (index) {\n\t\t\tif (index.order > 0) return index.range(this._args[1]._get(), null, false, false);\n\t\t\telse return index.range(null, this._args[1]._get(), false, false);\n\t\t};\n\t\tthis._ex = function (f) {\n\t\t\tif (this.fields()[f]!=null)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tthis.dump = function () {\n\t\t\treturn this._args[0].dump() +\" >= \" + this._args[1].dump()\n\t\t}\n\t\tthis.native = function () {\n\t\t\treturn this._args[0].native() +\" >= \" +this._args[1].native()\n\t\t}\n\t\tthis.native3 = function () {\n\t\t\tvar s = \"(function () {\\n\";\n\t\t\ts+= \"var v = \"+this._args[0].native3()+\"\\n\";\n\t\t\ts+= \"if (!v) return false;\\n\";\n\t\t\ts+= \"for (var i=0; i<v.length; i++ ) {\\n\";\n\t\t\ts+= \"if (v[i]>=\"+ this._args[1].native3()+\") return true;\\n\"\n\t\t\ts+= \"}\\nreturn false;})()\";\n\t\t\treturn s;\n\t\t}\n\t},\n\t$exists : function () {\n\t\tthis.op = \"$exists\";\n\t\tthis._index = function (index) {\n\t\t\tif (this._args[1]._get())\n\t\t\t\treturn index.values();\n\t\t\telse\n\t\t\t\treturn index.nuls();\n\t\t},\n\t\tthis._ex = function (f) {\n\t\t\tif (this.fields()[f]!=null)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tthis.dump = function () {\n\t\t\treturn this._args[0].dump() + \" exists \" + this._args[1].dump()\n\t\t}\n\t\tthis.native = function () {\n\t\t\tvar v = this._args[0].native();\n\t\t\treturn this._args[1]._get()?v:\"!\"+v;\n\t\t}\n\t\tthis.native3 = function () {\n\t\t\tvar exists = this._args[1]._get();\n\t\t\tvar s = \"(function () {\\n\";\n\t\t\ts+= \"var v = \"+this._args[0].native3()+\"\\n\";\n\t\t\ts+= \"if (!v) return \"+!exists+\";\\n\";\n\t\t\ts+= \"for (var i=0; i<v.length; i++ ) {\\n\";\n\t\t\tif (exists)\n\t\t\t\ts+= \"if (!v[i]) return false;\\n\"\n\t\t\telse\n\t\t\t\ts+= \"if (v[i]) return false;\\n\"\n\t\t\ts+= \"}\\nreturn true;})()\";\n\t\t\treturn s;\n\t\t}\n\t},\n\t$eq : function () {\n\t\tthis.op = \"$eq\";\n\t\tthis._index = function (index) {\n\t\t\treturn index.match(this._args[1]._get());\n\t\t},\n\t\tthis._ex = function (f) {\n\t\t\tif (this.fields()[f]!=null)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tthis.dump = function () {\n\t\t\treturn this._args[0].dump() +\" = \" + this._args[1].dump()\n\t\t}\n\t\tthis.native = function () {\n\t\t\treturn this._args[0].native() +\" === \" +this._args[1].native()\n\t\t}\n\t\tthis.native3 = function () {\n\t\t\tvar s = \"(function () {\\n\";\n\t\t\ts+= \"var v = \"+this._args[0].native3()+\"\\n\";\n\t\t\ts+= \"if (!v) return false;\\n\";\n\t\t\ts+= \"for (var i=0; i<v.length; i++ ) {\\n\";\n\t\t\ts+= \"if (v[i]===\"+ this._args[1].native3()+\") return true;\\n\"\n\t\t\ts+= \"}\\nreturn false;})()\";\n\t\t\treturn s;\n\t\t}\n\t},\n\t$ne : function () {\n\t\tthis.op = \"$ne\";\n\t\tthis._index = function (index) {\n\t\t\tvar m = index.match(this._args[1]._get());\n\t\t\tvar a = index.all();\n\t\t\treturn _.difference(a,m);\n\t\t},\n\t\tthis._ex = function (f) {\n\t\t\tif (this.fields()[f]!=null)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tthis.dump = function () {\n\t\t\treturn this._args[0].dump() +\" != \" + this._args[1].dump()\n\t\t}\n\t\tthis.native = function () {\n\t\t\treturn this._args[0].native() +\" != \" +this._args[1].native()\n\t\t}\n\t\tthis.native3 = function () {\n\t\t\tvar s = \"(function () {\\n\";\n\t\t\ts+= \"var v = \"+this._args[0].native3()+\"\\n\";\n\t\t\ts+= \"if (!v) return true;\\n\";\n\t\t\ts+= \"for (var i=0; i<v.length; i++ ) {\\n\";\n\t\t\ts+= \"if (v[i]==\"+ this._args[1].native3()+\") return false;\\n\"\n\t\t\ts+= \"}\\nreturn true;})()\";\n\t\t\treturn s;\n\t\t}\n\t},\n\t$in : function () {\n\t\tthis.op = \"$in\";\n\t\tthis._index = function (index) {\n\t\t\tvar u = _(this._args.slice(1)).map(function (v) { return v._get(); }).uniq().value();\n\t\t\treturn _(u).map(function (v) { return index.match(v); }).flattenDeep().value();\n\t\t},\n\t\tthis._ex = function (f) {\n\t\t\tif (this.fields()[f]!=null)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tthis.dump = function (obj) {\n\t\t\tvar s = this._args[0].dump()+\" in [\";\n\t\t\tfor (var i=1; i<this._args.length; i++) {\n\t\t\t\ts+=this._args[i].dump();\n\t\t\t\tif (i!=this._args.length-1)\n\t\t\t\t\ts+=\",\";\n\t\t\t}\n\t\t\treturn s+\"]\";\n\t\t}\n\t\tthis.native = function (obj) {\n\t\t\tif (this._args.length==1)\n\t\t\t\treturn \"true\";\n\t\t\tvar s = \"(function (obj) {\\n\"\n\t\t\ts+=\"var v = \"+this._args[0].native()+\";\\n\";\n\t\t\ts+=\"var args=[\";\n\t\t\tfor (var i=1; i<this._args.length; i++) {\n\t\t\t\ts+=JSON.stringify(this._args[i]._get());\n\t\t\t\tif (i!=this._args.length-1)\n\t\t\t\t\ts+=\",\";\n\t\t\t}\n\t\t\ts+=\"];\\n\"\n\t\t\ts+=\"for (var i=0; i<args.length; i++) { if (args[i]==v) return true };\\n\"\n\t\t\ts+=\"return false;\\n\"\n\t\t\ts+=\"})(obj)\";\n\t\t\treturn s;\n\t\t}\n\t\tthis.native3 = function (obj) {\n\t\t\tif (this._args.length==1)\n\t\t\t\treturn \"false\";\n\t\t\tvar s = \"(function (obj) {\\n\"\n\t\t\ts+=\"var v = \"+this._args[0].native3()+\";\\n\";\n\t\t\ts+= \"if (!v) return false;\\n\";\n\t\t\ts+=\"var args=[\";\n\t\t\tfor (var i=1; i<this._args.length; i++) {\n\t\t\t\ts+=JSON.stringify(this._args[i]._get());\n\t\t\t\tif (i!=this._args.length-1)\n\t\t\t\t\ts+=\",\";\n\t\t\t}\n\t\t\ts+=\"];\\n\"\n\t\t\ts+= \"for (var i=0; i<v.length; i++ ) {\\n\";\n\t\t\ts+=\"for (var j=0; j<args.length; j++) { if (args[j]==v[i]) return true };\\n\"\n\t\t\ts+=\"};return false;\\n\"\n\t\t\ts+=\"})(obj)\";\n\t\t\treturn s;\n\t\t}\n\t},\n\t$nin : function () {\n\t\tthis.op = \"$nin\";\n\t\tthis._index = function (index) {\n\t\t\tvar u = _(this._args.slice(1)).map(function (v) { return v._get(); }).uniq().value();\n\t\t\tvar x = _(u).map(function (v) { return index.match(v); }).flattenDeep().value();\n\t\t\tvar a = index.all(null, true);\n\t\t\treturn _.difference(a, x);\n\t\t},\n\t\tthis._ex = function (f) {\n\t\t\tif (this.fields()[f]!=null)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tthis.dump = function (obj) {\n\t\t\tvar s = this._args[0].dump()+\" nin [\";\n\t\t\tfor (var i=1; i<this._args.length; i++) {\n\t\t\t\ts+=this._args[i].dump();\n\t\t\t\tif (i!=this._args.length-1)\n\t\t\t\t\ts+=\",\";\n\t\t\t}\n\t\t\treturn s+\"]\";\n\t\t}\n\t\tthis.native = function (obj) {\n\t\t\tif (this._args.length==1)\n\t\t\t\treturn \"true\";\n\t\t\tvar s = \"(function (obj) {\\n\"\n\t\t\ts+=\"var v = \"+this._args[0].native()+\";\\n\";\n\t\t\ts+=\"var args=[\";\n\t\t\tfor (var i=1; i<this._args.length; i++) {\n\t\t\t\ts+=JSON.stringify(this._args[i]._get());\n\t\t\t\tif (i!=this._args.length-1)\n\t\t\t\t\ts+=\",\";\n\t\t\t}\n\t\t\ts+=\"];\\n\"\n\t\t\ts+=\"for (var i=0; i<args.length; i++) { if (args[i]==v) return false };\\n\"\n\t\t\ts+=\"return true;\\n\"\n\t\t\ts+=\"})(obj)\";\n\t\t\treturn s;\n\t\t}\n\t\tthis.native3 = function (obj) {\n\t\t\tif (this._args.length==1)\n\t\t\t\treturn \"true\";\n\t\t\tvar s = \"(function (obj) {\\n\"\n\t\t\ts+=\"var v = \"+this._args[0].native3()+\";\\n\";\n\t\t\ts+= \"if (!v) return true;\\n\";\n\t\t\ts+=\"var args=[\";\n\t\t\tfor (var i=1; i<this._args.length; i++) {\n\t\t\t\ts+=JSON.stringify(this._args[i]._get());\n\t\t\t\tif (i!=this._args.length-1)\n\t\t\t\t\ts+=\",\";\n\t\t\t}\n\t\t\ts+=\"];\\n\"\n\t\t\ts+= \"for (var i=0; i<v.length; i++ ) {\\n\";\n\t\t\ts+=\"for (var j=0; j<args.length; j++) { if (args[j]==v[i]) return false };\\n\"\n\t\t\ts+=\"};return true;\\n\"\n\t\t\ts+=\"})(obj)\";\n\t\t\treturn s;\n\t\t}\n\t},\n\t$all : function () {\n\t\tthis.op = \"$all\";\n\t\tthis._ex = function (f) {\n\t\t\t// check if our args do not have regexps,\n\t\t\t// if so index can't be used\n\t\t\tfor (var i=1; i<this._args.length; i++) {\n\t\t\t\tif (_.isRegExp(this._args[i]._get()))\n\t\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif (this.fields()[f]!=null)\n\t\t\t\treturn 1;\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tthis._index = function (index) {\n\t\t\tvar m = [];\n\t\t\tfor (var i=1; i<this._args.length; i++) {\n\t\t\t\tif (i==1)\n\t\t\t\t\tm = index.match(this._args[i]._get());\n\t\t\t\telse\n\t\t\t\t\tm = _.intersection(m,index.match(this._args[i]._get()));\n\t\t\t}\n\t\t\treturn m;\n\t\t},\n\t\tthis.native = function (obj) {\n\t\t\tif (this._args.length==1)\n\t\t\t\treturn \"true\";\n\t\t\tvar val,s = \"(function (obj) {\\n\"\n\t\t\ts+=\"var v = \"+this._args[0].native()+\";\\n\";\n\t\t\ts+= \"if (!v) return false;\\n\";\n\t\t\ts+=\"var args=[\";\n\t\t\tfor (var i=1; i<this._args.length; i++) {\n\t\t\t\tval=this._args[i]._get();\n\t\t\t\tif(val instanceof RegExp){\n\t\t\t\t\ts+=val;\n\t\t\t\t} else {\n\t\t\t\t\ts+=JSON.stringify(val);\n\t\t\t\t}\n\t\t\t\tif (i!=this._args.length-1)\n\t\t\t\t\ts+=\",\";\n\t\t\t}\n\t\t\ts+=\"];\\n\"\n\t\t\ts+= \"for (var i=0; i<args.length; i++ ) {\\n\";\n\t\t\ts+= \"if (args[i] instanceof RegExp)\\n\"\n\t\t\ts+=\"for (var j=0; j<v.length; j++) { if (args[i].test(v[j])) break; }\\n\"\n\t\t\ts+= \"else\\n\"\n\t\t\ts+=\"for (var j=0; j<v.length; j++) { if (v[j]==args[i]) break; };\\n\"\n\t\t\ts+=\"if (j==v.length) return false;\\n\";\n\t\t\ts+=\"};return true;\\n\"\n\t\t\ts+=\"})(obj)\";\n\n\t\t\treturn s;\n\t\t},\n\t\tthis.native3 = function (obj) {\n\t\t\tif (this._args.length==1)\n\t\t\t\treturn \"true\";\n\t\t\tvar val,s = \"(function (obj) {\\n\"\n\t\t\ts+=\"var vv = \"+this._args[0].native3()+\";\\n\";\n\t\t\ts+= \"if (!vv) return false;\\n\";\n\t\t\ts+= \"if (!Array.isArray(vv[0])) vv=[vv];\\n\";\n\t\t\ts+=\"var args=[\";\n\t\t\tfor (var i=1; i<this._args.length; i++) {\n\t\t\t\tval=this._args[i]._get();\n\t\t\t\tif(val instanceof RegExp){\n\t\t\t\t\ts+=val;\n\t\t\t\t} else {\n\t\t\t\t\ts+=JSON.stringify(val);\n\t\t\t\t}\n\t\t\t\tif (i!=this._args.length-1)\n\t\t\t\t\ts+=\",\";\n\t\t\t}\n\t\t\ts+=\"];\\n\"\n\t\t\ts+=\"for (var k=0; k<vv.length; k++) {\\n\";\n\t\t\ts+=\"var v = vv[k];\\n\"\n\t\t\ts+=\"for (var i=0; i<args.length; i++ ) {\\n\";\n\t\t\ts+= \"if (args[i] instanceof RegExp)\\n\"\n\t\t\ts+=\"for (var j=0; j<v.length; j++) { if (args[i].test(v[j])) break; }\\n\"\n\t\t\ts+= \"else\\n\"\n\t\t\ts+=\"for (var j=0; j<v.length; j++) { if (v[j]==args[i]) break; };\\n\"\n\t\t\ts+=\"if (j==v.length) return false;\\n\";\n\t\t\ts+=\"}};return true;\\n\"\n\t\t\ts+=\"})(obj)\";\n\t\t\treturn s;\n\t\t}\n\t},\n\t$not : function () {\n\t\tthis.op = \"$not\";\n\t\tthis._index = function (index) {\n\t\t\tvar m = this._args[1]._index(index);\n\t\t\tvar a = index.all();\n\t\t\treturn _.difference(a,m);\n\t\t},\n\t\tthis._ex = function (f) {\n\t\t\treturn this._args[1]._ex(f);\n\t\t}\n\t\tthis.dump = function () {\n\t\t\treturn \"!(\"+this._args[1].dump()+\")\";\n\t\t}\n\t\tthis.native = function () {\n\t\t\treturn \"!(\"+this._args[1].native()+\")\";\n\t\t}\n\t\tthis.native3 = function () {\n\t\t\treturn \"!(\"+this._args[1].native3()+\")\";\n\t\t}\n\t},\n\t$and : function () {\n\t\tthis.op = \"$and\";\n\t\tthis._index = function (index) {\n\t\t\tvar ops = [];\n\t\t\tfor (var i=0; i<this._args.length; i++) {\n\t\t\t\tops.push(this._args[i]._index(index));\n\t\t\t}\n\t\t\treturn _.intersection.apply(_,ops);\n\t\t}\n\t\tthis.split = function (f) {\n\t\t\tvar s = new ops.$and();\n\t\t\tvar d = [];\n\t\t\tvar o = [];\n\t\t\tvar i = 0;\n\n\t\t\tfor (i=0; i<this._args.length; i++) {\n\t\t\t\tif (this._args[i].op==\"$and\" || this._args[i].op==\"$or\" ) {\n\t\t\t\t\tvar sub = this._args[i].split(f);\n\t\t\t\t\tif (this._args[i]._args.length>0) {\n\t\t\t\t\t\t_.each(this._args[i]._args, function (a) {\n\t\t\t\t\t\t\to.push(a);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif (sub._args.length>0) {\n\t\t\t\t\t\t_.each(sub._args, function (a) {\n\t\t\t\t\t\t\td.push(a);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tvar ex = this._args[i]._ex(f);\n\t\t\t\t\tif (ex==1)\n\t\t\t\t\t\td.push(this._args[i])\n\t\t\t\t\telse\n\t\t\t\t\t\to.push(this._args[i])\n\t\t\t\t}\n\t\t\t}\n\t\t\t// special check for paired ops\n\t\t\tvar l=null,g=null;\n\t\t\tfor (i=0; i<d.length; i++) {\n\t\t\t\tif (d[i].op==\"$lt\" || d[i].op==\"$lte\")\n\t\t\t\t\tl = i;\n\t\t\t\tif (d[i].op==\"$gt\" || d[i].op==\"$gte\")\n\t\t\t\t\tg = i;\n\t\t\t}\n\t\t\tif (l!=null && g!=null) {\n\t\t\t\tvar r = new ops.$range();\n\t\t\t\tr._args = [d[l]._args[0]];\n\t\t\t\tr._args.push(d[g]._args[1]);\n\t\t\t\tr._args.push(d[l]._args[1]);\n\t\t\t\tr._args.push(new value(d[g].op==\"$gte\"?false:true));\n\t\t\t\tr._args.push(new value(d[l].op==\"$lte\"?false:true));\n\t\t\t\td.splice(l,1);\n\t\t\t\td.splice(l<g?g:g-1,1);\n\t\t\t\td.push(r);\n\t\t\t}\n\t\t\ts._args = d;\n\t\t\tthis._args = o;\n\t\t\treturn s;\n\t\t}\n\t\tthis._ex = function (f) {\n\t\t\tvar r = -1;\n\t\t\tfor (var i=0; i<this._args.length; i++) {\n\t\t\t\tvar ex = this._args[i]._ex(f);\n\t\t\t\tif (ex==0)\n\t\t\t\t\treturn 0;\n\t\t\t\tif (ex==1)\n\t\t\t\t\tr=1;\n\t\t\t}\n\t\t\treturn r;\n\t\t}\n\t\tthis.dump = function (obj) {\n\t\t\tvar s = \"(\"\n\t\t\tfor (var i=0; i<this._args.length; i++) {\n\t\t\t\ts+=this._args[i].dump();\n\t\t\t\tif (i!=this._args.length-1)\n\t\t\t\t\ts+=\",\";\n\t\t\t}\n\t\t\treturn s+\")\";\n\t\t}\n\t\tthis.native = function (obj) {\n\t\t\tif (this._args.length==0)\n\t\t\t\treturn \"true\";\n\t\t\tvar s = \"(\"\n\t\t\tfor (var i=0; i<this._args.length; i++) {\n\t\t\t\ts+=this._args[i].native();\n\t\t\t\tif (i!=this._args.length-1)\n\t\t\t\t\ts+=\" && \";\n\t\t\t}\n\t\t\treturn s+\")\";\n\t\t}\n\t\tthis.native3 = function (obj) {\n\t\t\tif (this._args.length==0)\n\t\t\t\treturn \"true\";\n\t\t\tvar s = \"(\"\n\t\t\tfor (var i=0; i<this._args.length; i++) {\n\t\t\t\ts+=this._args[i].native3();\n\t\t\t\tif (i!=this._args.length-1)\n\t\t\t\t\ts+=\" && \";\n\t\t\t}\n\t\t\treturn s+\")\";\n\t\t}\n\t},\n\t$or : function () {\n\t\tthis.op = \"$or\";\n\t\tthis._ex = function (f) {\n\t\t\treturn 0;\n\t\t}\n\t\tthis.dump = function (obj) {\n\t\t\tvar s = \"(\"\n\t\t\tfor (var i=0; i<this._args.length; i++) {\n\t\t\t\ts+=this._args[i].dump();\n\t\t\t\tif (i!=this._args.length-1)\n\t\t\t\t\ts+=\" || \";\n\t\t\t}\n\t\t\treturn s+\")\";\n\t\t}\n\t\tthis.native = function (obj) {\n\t\t\tif (this._args.length==0)\n\t\t\t\treturn \"true\";\n\t\t\tvar s = \"(\"\n\t\t\tfor (var i=0; i<this._args.length; i++) {\n\t\t\t\ts+=this._args[i].native();\n\t\t\t\tif (i!=this._args.length-1)\n\t\t\t\t\ts+=\" || \";\n\t\t\t}\n\t\t\treturn s+\")\";\n\t\t}\n\t\tthis.native3 = function (obj) {\n\t\t\tif (this._args.length==0)\n\t\t\t\treturn \"true\";\n\t\t\tvar s = \"(\"\n\t\t\tfor (var i=0; i<this._args.length; i++) {\n\t\t\t\ts+=this._args[i].native3();\n\t\t\t\tif (i!=this._args.length-1)\n\t\t\t\t\ts+=\" || \";\n\t\t\t}\n\t\t\treturn s+\")\";\n\t\t}\n\t},\n\t$nor : function () {\n\t\tthis.op = \"$nor\";\n\t\tthis._ex = function (f) {\n\t\t\treturn 0;\n\t\t}\n\t\tthis.dump = function (obj) {\n\t\t\tvar s = \"!(\"\n\t\t\tfor (var i=0; i<this._args.length; i++) {\n\t\t\t\ts+=this._args[i].dump();\n\t\t\t\tif (i!=this._args.length-1)\n\t\t\t\t\ts+=\" || \";\n\t\t\t}\n\t\t\treturn s+\")\";\n\t\t}\n\t\tthis.native = function (obj) {\n\t\t\tif (this._args.length==0)\n\t\t\t\treturn \"true\";\n\t\t\tvar s = \"!(\"\n\t\t\tfor (var i=0; i<this._args.length; i++) {\n\t\t\t\ts+=this._args[i].native();\n\t\t\t\tif (i!=this._args.length-1)\n\t\t\t\t\ts+=\" || \";\n\t\t\t}\n\t\t\treturn s+\")\";\n\t\t}\n\t\tthis.native3 = function (obj) {\n\t\t\tif (this._args.length==0)\n\t\t\t\treturn \"true\";\n\t\t\tvar s = \"!(\"\n\t\t\tfor (var i=0; i<this._args.length; i++) {\n\t\t\t\ts+=this._args[i].native3();\n\t\t\t\tif (i!=this._args.length-1)\n\t\t\t\t\ts+=\" || \";\n\t\t\t}\n\t\t\treturn s+\")\";\n\t\t}\n\t},\n\t$where: function () {\n\t\tthis.op = \"$where\";\n\t\tthis._ex = function (f) {\n\t\t\treturn 0;\n\t\t};\n\t\tthis.dump = function (obj) {\n\t\t\treturn \"where(\" + this._args[0].dump() + \")\";\n\t\t};\n\t\tthis.native = this.native3 = function (obj) {\n\t\t\tvar v = this._args[0]._get();\n\t\t\tif (_.isFunction(v)) return '(' + v + ').call(obj)';\n\t\t\telse if (v instanceof tdb.Code) {\n\t\t\t\tif (_.isFunction(v.code)) return '(function () { with (' + JSON.stringify(v.scope) + ') return (' + v.code + ').call(obj); })()';\n\t\t\t\telse return '(function () { with (' + JSON.stringify(v.scope) + ') return (' + v.code + '); }).call(obj)';\n\t\t\t} else return '(function () { return (' + v + '); }).call(obj)';\n\t\t};\n\t},\n\t$regex: function () {\n\t\tthis.op = \"$regex\";\n\t\tthis._ex = function (f) {\n\t\t\treturn 0;\n\t\t};\n\t\tthis._get = function (obj) {\n\t\t\tvar match = this._args[0].native();\n\t\t\tmatch = match.replace(/\\\"/g,\"\");\n\t\t\tvar opts = this._args.length>1?this._args[1].native():'';\n\t\t\topts = opts.replace(/\\\"/g,\"\");\n\t\t\treturn new RegExp(match,opts);\n\t\t}\n\t\tthis.dump = function () {\n\t\t\treturn this._args[0].dump() +\" ~ \" + this._args[1].dump()\n\t\t}\n\t\tthis.native = function () {\n\t\t\tvar match = this._args[1].native();\n\t\t\tmatch = match.replace(/\\/+/g, \"\\\\/\").replace(/\\\\\\\\/g,\"\\\\\").replace(/^\\\"/,\"/\").replace(/\\\"$/,\"/\");\n\t\t\tvar opts = this._args.length>2?this._args[2].native():'';\n\t\t\topts = opts.replace(/\\\"/g,\"\");\n\t\t\tvar s = '('+match+opts+').test('+this._args[0].native() +')';\n\t\t\treturn s;\n\t\t}\n\t\tthis.native3 = function () {\n\t\t\tvar match = this._args[1].native();\n\t\t\tmatch = match.replace(/\\/+/g, \"\\\\/\").replace(/\\\\\\\\/g,\"\\\\\").replace(/^\\\"/,\"/\").replace(/\\\"$/,\"/\");\n\t\t\tvar opts = this._args.length>2?this._args[2].native():'';\n\t\t\topts = opts.replace(/\\\"/g,\"\");\n\t\t\tvar s = \"(function () {\\n\";\n\t\t\ts+= \"var v = \"+this._args[0].native3()+\"\\n\";\n\t\t\ts+= \"if (!v) return false;\\n\";\n\t\t\ts+= \"for (var i=0; i<v.length; i++ ) {\\n\";\n\t\t\ts+= 'if (('+match+opts+').test(v[i])) return true;\\n'\n\t\t\ts+= \"}\\nreturn false;})()\";\n\t\t\treturn s;\n\t\t}\n\t}\n}\n\n_.each(ops, function (op) {\n\top.prototype.fields = function () {\n\t\tvar f = {};\n\t\t_.each(this._args, function (a) {\n\t\t\tif (a.op==\"f\")\n\t\t\t\tf[a.f]=1;\n\t\t\telse if (a.op!=\"v\") {\n\t\t\t\tvar s = a.fields();\n\t\t\t\t_.each(s,function (n,k) {\n\t\t\t\t\tf[k]=1;\n\t\t\t\t})\n\t\t\t}\n\t\t})\n\t\treturn f;\n\t}\n})\n\nvar field = function (k) {\n\tthis.op = \"f\";\n\tthis.f = k;\n\tthis.dump = function () {\n\t\treturn k;\n\t}\n\tthis.native = function () {\n\t\tvar path = k.split(\".\");\n\t\tvar s = \"(\";\n\t\tvar ps = \"obj\";\n\t\tfor (var i=0;i<path.length;i++) {\n\t\t\tps+=\"['\"+path[i]+\"']\";\n\t\t\tif (i!=path.length-1)\n\t\t\t\ts+=ps+ \" && \";\n\t\t\telse\n\t\t\t\ts+= \"(\"+ps+\" && \"+ps+\".valueOf()\"+\") )\";\n\t\t}\n\t\treturn s;\n\t}\n\tthis.native3 = function () {\n\t\tfunction steep(ps, path, i) {\n\t\t\tps+=\"['\"+path[i]+\"']\";\n\t\t\tif (path.length==i)\n\t\t\t\treturn \"\";\n\t\t\ti++;\n\t\t\tvar s = \"\";\n\t\t\ts+= \"v\"+i+\"=\"+ps+\"\\n\";\n\t\t\ts+= \"if (!v\"+i+\") return null;\\n\"\n\t\t\tif (path.length!=i) {\n\t\t\t\ts+= \"if (Array.isArray(v\"+i+\")) {\\n\";\n\t\t\t\ts+= \"for (i\"+i+\"=0; i\"+i+\"<v\"+i+\".length; i\"+i+\"++) {\\n\";\n\t\t\t\ts+= steep(\"v\"+i+\"[i\"+i+\"]\",path,i);\n\t\t\t\ts+= \"}\\n}\\nelse\\n{\\n\";\n\t\t\t\ts+= steep(\"v\"+i,path,i);\n\t\t\t\ts+= \"}\\n\"\n\t\t\t} else\n\t\t\t\ts+= \"res.push(v\"+i+\".valueOf())\\n\";\n\t\t\treturn s;\n\t\t}\n\n\t\tvar path = k.split(\".\");\n\t\tif (path.length==1)\n\t\t\treturn \"Array.isArray(obj['\"+k+\"'])?obj['\"+k+\"']:[obj['\" + k + \"'] && obj['\"+k+\"'].valueOf()]\";\n\t\telse {\n\t\t\tvar s = \"(function () {\\n\";\n\t\t\tvar ps = \"obj\";\n\t\t\ts+=\"var res=[]\\n\";\n\t\t\tfor (var i=0; i<path.length; i++) {\n\t\t\t\ts+=\"var v\"+i+\",i\"+i+\";\\n\";\n\t\t\t}\n\t\t\ts+=steep(ps,path,0);\n\t\t\treturn s+\"\\nreturn [].concat.apply([],res);})()\";\n\t\t}\n\n\t}\n}\n\n\nvar value = function (v) {\n\tthis.op = \"v\";\n\tthis.v = null;\n\n\tif (_.isNumber(v) || _.isString(v) || _.isFunction(v) || _.isBoolean(v))\n\t\tthis.v = v\n\telse if (_.isObject(v) && v.valueOf)\n\t\tthis.v = v.valueOf();\n\telse if (v !== null)\n\t\tconsole.log(\"WARNING: Using unrecognized value in query\",v)\n\n\tthis._get = function (obj) {\n\t\treturn this.v;\n\t}\n\tthis.dump = function () {\n\t\treturn this.v;\n\t}\n\tthis.native3 = this.native = function () {\n\t\treturn _.isFunction(this.v) ? this.v.toString() : JSON.stringify(this.v);\n\t}\n}\n\nfunction stree(query,ctx,opf) {\n\tvar args = [];\n\tif (_.isArray(query)) {\n\t\t_.each(query, function (v) {\n\t\t\tvar sub = stree(v);\n\t\t\t_.each(sub,function (v) {\n\t\t\t\targs.push(v);\n\t\t\t})\n\t\t})\n\t} else if (_.isPlainObject(query)) {\n\t\tvar options = null;\n\t\t_.each(query, function (v,k) {\n\t\t\tvar op = ops[k];\n\t\t\tvar n = null;\n\t\t\tif (op!=null) {\n\t\t\t\tn = new op();\n\t\t\t\tn._args = stree(v,ctx,k);\n\t\t\t\tif (ctx!=null)\n\t\t\t\t\tn._args.splice(0,0,ctx);\n\t\t\t\tif (options) {\n\t\t\t\t\tn._args.push(options);\n\t\t\t\t\toptions = null;\n\t\t\t\t}\n\t\t\t\targs.push(n);\n\t\t\t}\n\t\t\telse if (k==\"$options\") {\n\t\t\t\tif (args.length>0)\n\t\t\t\t\targs[args.length-1]._args.push(new value(v))\n\t\t\t\toptions = new value(v);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (_.isPlainObject(v)) {\n\t\t\t\t\tvar sub = stree(v,new field(k));\n\t\t\t\t\tif (sub.length==1)\n\t\t\t\t\t\targs.push(sub[0]);\n\t\t\t\t\telse if (sub.length>1) {\n\t\t\t\t\t\tn = new ops[\"$and\"];\n\t\t\t\t\t\tn._args = sub;\n\t\t\t\t\t\targs.push(n);\n\t\t\t\t\t}\n\t\t\t\t} else if (_.isRegExp(v)) {\n\t\t\t\t\tn = new ops[\"$regex\"]();\n\t\t\t\t\tn._args = [new field(k), new value(v.source), new value((v.global?'g':'')+(v.ignoreCase?'i':'')+(v.multiline?'m':''))];\n\t\t\t\t\targs.push(n);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tn = new ops[\"$eq\"]();\n\t\t\t\t\tn._args = [new field(k)];\n\t\t\t\t\tvar sub = stree(v);\n\t\t\t\t\t_.each(sub,function (v) {\n\t\t\t\t\t\tn._args.push(v);\n\t\t\t\t\t})\n\t\t\t\t\targs.push(n);\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t} else {\n\t\tif (_.isRegExp(query)) {\n\t\t\tvar v, n;\n\t\t\tif (opf!=\"$regex\") {\n\t\t\t\tv = query;\n\t\t\t\tn = new ops[\"$regex\"]();\n\t\t\t\tn._args = [new value(v.source), new value((v.global?'g':'')+(v.ignoreCase?'i':'')+(v.multiline?'m':''))];\n\t\t\t\tif (ctx!=null)\n\t\t\t\t\tn._args.splice(0,0,ctx);\n\t\t\t\targs.push(n);\n\t\t\t} else {\n\t\t\t\tv = query.toString();\n\t\t\t\treturn [new value(v.substring(1,v.length-1))]\n\t\t\t}\n\t\t} else\n\t\t\treturn [new value(query)];\n\t}\n\treturn args;\n}\n\nexpo.matcher = function (query) {\n\tvar aq = [];\n\t_.each(query, function (v,k) {\n\t\tvar o = {};\to[k]=v;\n\t\taq.push(o)\n\t})\n\tvar wrap={$and:aq};\n\tvar res = stree(wrap);\n\treturn res[0];\n}\n\nexpo.field = field;\n","/home/travis/build/npmtest/node-npmtest-tingodb/node_modules/tingodb/lib/ObjectId.js":"var _ = require('lodash');\n\nvar inproc_id = -1;\nvar tempset = {};\nfunction ObjectID(val) {\n\t// every new instance will have temporary inproc unique value\n\t// minus sign will let know to db layer that value is temporary\n\t// and need to be replaced\n\tthis.id = --inproc_id;\n\tthis._init(val);\n\t// we need to keep track all temporary instances with goal\n\t// to update them at later tima\n\tif (this.id<0) {\n\t\tif (!tempset[this.id])\n\t\t\ttempset[this.id]=[this];\n\t\telse\n\t\t\ttempset[this.id].push(this);\n\t}\n}\n\nObjectID.prototype._persist = function (v) {\n\tvar oldid = this.id;\n\tif (oldid<0) {\n\t\t_.each(tempset[oldid], function (oid) {\n\t\t\toid.id = v;\n\t\t});\n\t\tdelete tempset[oldid];\n\t}\n}\n\nObjectID.prototype._init = function (val) {\n\tif (_.isNumber(val))\n\t\tthis.id = val;\n\telse if (val instanceof ObjectID)\n\t\tthis.id = val.id;\n\telse if (_.isString(val)) {\n\t\tif (/^-?\\d+$/.test(val))\n\t\t\tthis.id = parseInt(val)\n\t\telse\n\t\t\tthis.id = NaN;\n\t}\n\tif (val && isNaN(this.id))\n\t\tthrow new Error(\"ObjectId should be ObjectId (whatever it is designed to be) \"+val)\n}\n\nObjectID.prototype.toString = ObjectID.prototype.inspect = function () {\n\treturn this.id.toString();\n}\n\nObjectID.prototype.toJSON = ObjectID.prototype.valueOf = function () {\n\treturn this.id;\n}\n\nObjectID.prototype.equals = function (val) {\n\tif (val instanceof ObjectID)\n\t\treturn this.id==val.id;\n\telse {\n\t\tvar temp = new ObjectID(val);\n\t\treturn this.id==temp.id;\n\t}\n}\n\n// Something for fake compatibiltity with BSON.ObjectId\nObjectID.prototype.toHexString = function () {\n\tvar l = this.id.toString();\n\tvar zeros = \"000000000000000000000000\";\n\treturn zeros.substr(0,zeros.length - l.length)+l;\n}\n\nObjectID.createFromHexString = ObjectID.createFromString = function (str) {\n\treturn new ObjectID(str);\n}\n\nmodule.exports = ObjectID;\n","/home/travis/build/npmtest/node-npmtest-tingodb/node_modules/tingodb/lib/tbinary.js":"var _ = require(\"lodash\");\n\n/**\n * Module dependencies.\n */\nif (typeof window === 'undefined') {\n  var Buffer = require('buffer').Buffer; // TODO just use global Buffer\n}\n\n// Binary default subtype\nvar BSON_BINARY_SUBTYPE_DEFAULT = 0;\n\n/**\n * @ignore\n * @api private\n */\nvar writeStringToArray = function(data) {\n  // Create a buffer\n  var buffer = typeof Uint8Array !== 'undefined' ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);\n  // Write the content to the buffer\n  for(var i = 0; i < data.length; i++) {\n    buffer[i] = data.charCodeAt(i);\n  }\n  // Write the string to the buffer\n  return buffer;\n}\n\n/**\n * Convert Array ot Uint8Array to Binary String\n *\n * @ignore\n * @api private\n */\nvar convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {\n  var result = \"\";\n  for(var i = startIndex; i < endIndex; i++) {\n   result = result + String.fromCharCode(byteArray[i]);\n  }\n  return result;\n};\n\n/**\n * A class representation of the BSON Binary type.\n *\n * Sub types\n *  - **BSON.BSON_BINARY_SUBTYPE_DEFAULT**, default BSON type.\n *  - **BSON.BSON_BINARY_SUBTYPE_FUNCTION**, BSON function type.\n *  - **BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY**, BSON byte array type.\n *  - **BSON.BSON_BINARY_SUBTYPE_UUID**, BSON uuid type.\n *  - **BSON.BSON_BINARY_SUBTYPE_MD5**, BSON md5 type.\n *  - **BSON.BSON_BINARY_SUBTYPE_USER_DEFINED**, BSON user defined type.\n *\n * @class Represents the Binary BSON type.\n * @param {Buffer} buffer a buffer object containing the binary data.\n * @param {Number} [subType] the option binary type.\n * @return {Grid}\n */\nfunction Binary(buffer, subType) {\n  if(!(this instanceof Binary)) return new Binary(buffer, subType);\n\n  this._bsontype = 'Binary';\n\n  if(buffer instanceof Number) {\n    this.sub_type = buffer;\n    this.position = 0;\n  } else {\n    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;\n    this.position = 0;\n  }\n\n  if(buffer != null && !(buffer instanceof Number)) {\n    // Only accept Buffer, Uint8Array or Arrays\n    if(_.isString(buffer)) {\n      // Different ways of writing the length of the string for the different types\n      if(typeof Buffer !== 'undefined') {\n        this.buffer = new Buffer(buffer);\n      } else if(typeof Uint8Array !== 'undefined' || _.isArray(buffer)) {\n        this.buffer = writeStringToArray(buffer);\n      } else {\n        throw new Error(\"only String, Buffer, Uint8Array or Array accepted\");\n      }\n    } else {\n      this.buffer = buffer;\n    }\n    this.position = buffer.length;\n  } else {\n    if(typeof Buffer !== 'undefined') {\n      this.buffer =  new Buffer(Binary.BUFFER_SIZE);\n    } else if(typeof Uint8Array !== 'undefined'){\n      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));\n    } else {\n      this.buffer = new Array(Binary.BUFFER_SIZE);\n    }\n    // Set position to start of buffer\n    this.position = 0;\n  }\n}\n\n/**\n * Updates this binary with byte_value.\n *\n * @param {Character} byte_value a single byte we wish to write.\n * @api public\n */\nBinary.prototype.put = function put(byte_value) {\n  // If it's a string and a has more than one character throw an error\n  if(byte_value['length'] != null && !_.isNumber(byte_value) && byte_value.length != 1) throw new Error(\"only accepts single character String, Uint8Array or Array\");\n  if(!_.isNumber(byte_value) && byte_value < 0 || byte_value > 255) throw new Error(\"only accepts number in a valid unsigned byte range 0-255\");\n\n  // Decode the byte value once\n  var decoded_byte = null;\n  if(_.isString(byte_value)) {\n    decoded_byte = byte_value.charCodeAt(0);\n  } else if(byte_value['length'] != null) {\n    decoded_byte = byte_value[0];\n  } else {\n    decoded_byte = byte_value;\n  }\n\n  if(this.buffer.length > this.position) {\n    this.buffer[this.position++] = decoded_byte;\n  } else {\n    if(typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer)) {\n      // Create additional overflow buffer\n      var buffer = new Buffer(Binary.BUFFER_SIZE + this.buffer.length);\n      // Combine the two buffers together\n      this.buffer.copy(buffer, 0, 0, this.buffer.length);\n      this.buffer = buffer;\n      this.buffer[this.position++] = decoded_byte;\n    } else {\n      var buffer = null;\n      // Create a new buffer (typed or normal array)\n      if (_.isBuffer(this.buffer)) {\n        buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length));\n      } else {\n        buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length);\n      }\n\n      // We need to copy all the content to the new array\n      for(var i = 0; i < this.buffer.length; i++) {\n        buffer[i] = this.buffer[i];\n      }\n\n      // Reassign the buffer\n      this.buffer = buffer;\n      // Write the byte\n      this.buffer[this.position++] = decoded_byte;\n    }\n  }\n};\n\n/**\n * Writes a buffer or string to the binary.\n *\n * @param {Buffer|String} string a string or buffer to be written to the Binary BSON object.\n * @param {Number} offset specify the binary of where to write the content.\n * @api public\n */\nBinary.prototype.write = function write(string, offset) {\n  offset = _.isNumber(offset) ? offset : this.position;\n\n  // If the buffer is to small let's extend the buffer\n  if(this.buffer.length < offset + string.length) {\n    var buffer = null;\n    // If we are in node.js\n    if(typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer)) {\n      buffer = new Buffer(this.buffer.length + string.length);\n      this.buffer.copy(buffer, 0, 0, this.buffer.length);\n    } else if(_.isBuffer(this.buffer)) {\n      // Create a new buffer\n      buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length))\n      // Copy the content\n      for(var i = 0; i < this.position; i++) {\n        buffer[i] = this.buffer[i];\n      }\n    }\n\n    // Assign the new buffer\n    this.buffer = buffer;\n  }\n\n  if(typeof Buffer !== 'undefined' && Buffer.isBuffer(string) && Buffer.isBuffer(this.buffer)) {\n    string.copy(this.buffer, offset, 0, string.length);\n    this.position = (offset + string.length) > this.position ? (offset + string.length) : this.position;\n    // offset = string.length\n  } else if(typeof Buffer !== 'undefined' && _.isString(string) && _.isBuffer(this.buffer)) {\n    this.buffer.write(string, 'binary', offset);\n    this.position = (offset + string.length) > this.position ? (offset + string.length) : this.position;\n    // offset = string.length;\n  } else if (_.isBuffer(string) || _.isArray(string) && !_.isString(string)) {\n    for(var i = 0; i < string.length; i++) {\n      this.buffer[offset++] = string[i];\n    }\n\n    this.position = offset > this.position ? offset : this.position;\n  } else if(_.isString(string)) {\n    for(var i = 0; i < string.length; i++) {\n      this.buffer[offset++] = string.charCodeAt(i);\n    }\n\n    this.position = offset > this.position ? offset : this.position;\n  }\n};\n\n/**\n * Reads **length** bytes starting at **position**.\n *\n * @param {Number} position read from the given position in the Binary.\n * @param {Number} length the number of bytes to read.\n * @return {Buffer}\n * @api public\n */\nBinary.prototype.read = function read(position, length) {\n  length = length && length > 0\n    ? length\n    : this.position;\n\n  // Let's return the data based on the type we have\n  if(this.buffer['slice']) {\n    return this.buffer.slice(position, position + length);\n  } else {\n    // Create a buffer to keep the result\n    var buffer = typeof Uint8Array !== 'undefined' ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);\n    for(var i = 0; i < length; i++) {\n      buffer[i] = this.buffer[position++];\n    }\n  }\n  // Return the buffer\n  return buffer;\n};\n\n/**\n * Returns the value of this binary as a string.\n *\n * @return {String}\n * @api public\n */\nBinary.prototype.value = function value(asRaw) {\n  asRaw = asRaw == null ? false : asRaw;\n\n  // If it's a node.js buffer object\n  if(typeof Buffer !== 'undefined' && Buffer.isBuffer(this.buffer)) {\n    return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString('binary', 0, this.position);\n  } else {\n    if(asRaw) {\n      // we support the slice command use it\n      if(this.buffer['slice'] != null) {\n        return this.buffer.slice(0, this.position);\n      } else {\n        // Create a new buffer to copy content to\n        var newBuffer = _.isBuffer(this.buffer) ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);\n        // Copy content\n        for(var i = 0; i < this.position; i++) {\n          newBuffer[i] = this.buffer[i];\n        }\n        // Return the buffer\n        return newBuffer;\n      }\n    } else {\n      return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);\n    }\n  }\n};\n\n/**\n * Length.\n *\n * @return {Number} the length of the binary.\n * @api public\n */\nBinary.prototype.length = function length() {\n  return this.position;\n};\n\n/**\n * @ignore\n * @api private\n */\nBinary.prototype.toJSON = function() {\n  return this.buffer != null ? this.buffer.toString('base64') : '';\n}\n\n/**\n * @ignore\n * @api private\n */\nBinary.prototype.toString = function(format) {\n  return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : '';\n}\n\nBinary.BUFFER_SIZE = 256;\n\n/**\n * Default BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_DEFAULT = 0;\n/**\n * Function BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_FUNCTION = 1;\n/**\n * Byte Array BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_BYTE_ARRAY = 2;\n/**\n * OLD UUID BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_UUID_OLD = 3;\n/**\n * UUID BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_UUID = 4;\n/**\n * MD5 BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_MD5 = 5;\n/**\n * User BSON type\n *\n * @classconstant SUBTYPE_DEFAULT\n **/\nBinary.SUBTYPE_USER_DEFINED = 128;\n\n/**\n * Expose.\n */\nexports.Binary = Binary;\n","/home/travis/build/npmtest/node-npmtest-tingodb/node_modules/tingodb/lib/tcache.js":"// var BPlusTree = require('./bplustree');\n\nfunction tcache (tdb, size) {\n\tthis._tdb = tdb;\n\tthis.size = size || 1000;\n\tthis._cache = [];\n\tthis._cache.length = this.size;\n\tthis.clear();\n}\n\ntcache.prototype.clear = function () {\n\tfor (var i=0; i<this._cache.length; i++) {\n\t\tthis._cache[i]={k:null};\n\t}\n};\n\ntcache.prototype.set = function (k,v) {\n\tthis._cache[k%this.size] = {k:k,v:this._tdb._cloneDeep(v)};\n};\n\ntcache.prototype.unset = function (k) {\n\tvar c = this._cache[k%this.size];\n\tif (c.k==k)\n\t\tthis._cache[k%this.size]={k:null};\n};\n\ntcache.prototype.get = function (k, unsafe) {\n\tvar c = this._cache[k%this.size];\n\treturn c.k == k ? (unsafe?c.v:this._tdb._cloneDeep(c.v)) : null;\n};\n\nmodule.exports = tcache;\n","/home/travis/build/npmtest/node-npmtest-tingodb/node_modules/tingodb/lib/tcode.js":"/**\n * A class representation of the BSON Code type.\n *\n * @class Represents the BSON Code type.\n * @param {String|Function} code a string or function.\n * @param {Object} [scope] an optional scope for the function.\n * @return {Code}\n */\nfunction Code(code, scope) {\n  if(!(this instanceof Code)) return new Code(code, scope);\n\n  this._bsontype = 'Code';\n  this.code = code;\n  this.scope = scope == null ? {} : scope;\n}\n\n/**\n * @ignore\n * @api private\n */\nCode.prototype.toJSON = function() {\n  return {scope:this.scope, code:this.code};\n}\n\nexports.Code = Code;\n","/home/travis/build/npmtest/node-npmtest-tingodb/node_modules/tingodb/lib/tcoll.js":"var safe = require('safe');\nvar _ = require('lodash');\nvar crypto = require('crypto');\nvar fs = require('fs');\nvar path = require('path');\nvar tcursor = require('./tcursor');\nvar wqueue = require('./wqueue');\nvar tindex = require('./tindex');\nvar tcache = require(\"./tcache\");\nvar Code = require('./tcode').Code;\nvar tutils = require('./utils');\nvar Updater = require('./updater');\n\nfunction tcoll(tdb) {\n\tthis._tdb = null;\n\tthis._name = null;\n\tthis._store = Object.create ? Object.create(null) : {};\n\tthis._fd = null;\n\tthis._fsize = null;\n\tthis._id = 1;\n\tthis._wq = new wqueue();\n\tthis._tq = null;\n\tthis._idx = Object.create ? Object.create(null) : {};\n\tthis._cache = null;\n\t// this._mc = {};\n\tthis._check1 = Math.random()*100+1;\n\t// native mongo db compatibility attrs\n\tthis.collectionName = null;\n\tif (tdb._stype==\"mem\") {\n\t\tthis.init = this.initM;\n\t\tthis._put = this._putM;\n\t\tthis._get = this._getM;\n\t} else {\n\t\tthis.init = this.initFS;\n\t\tthis._put = this._putFS;\n\t\tthis._get = this._getFS;\n\t}\n}\n\nmodule.exports = tcoll;\n\ntcoll.prototype.initM = function (tdb, name, options, create, cb) {\n\tvar self= this;\n\tthis._tdb = tdb;\n\ttdb._mstore = tdb._mstore || Object.create ? Object.create(null) : {};\n\tthis.collectionName = this._name = name;\n\tif (options.strict) {\n\t\tvar exists = tdb._mstore[name];\n\t\tif (exists && create) return cb(new Error(\"Collection \" + self._name + \" already exists. Currently in safe mode.\"));\n\t\telse if (!exists && !create) return cb(new Error(\"Collection \" + self._name + \" does not exist. Currently in safe mode.\"));\n\t}\n\ttdb._mstore[name] = this._mstore = tdb._mstore[name] || [];\n\tfor (var k=0; k< this._mstore.length; k++) {\n\t\tvar o = this._mstore[k];\n\t\tif (o) {\n\t\t\tself._store[simplifyKey(o._id)]={pos:k+1};\n\t\t}\n\t}\n\tthis._tq = new wqueue(100, function (cb) {\n\t\t// update indexes\n\t\tsafe.eachOfSeries(self._store, function (rec, k, cb) {\n\t\t\tself._get(rec.pos, false, safe.sure(cb, function (obj) {\n\t\t\t\tvar id = simplifyKey(obj._id);\n\t\t\t\t_.each(self._idx,function(v, k) {\n\t\t\t\t\tv.set(obj, id);\n\t\t\t\t});\n\t\t\t\tcb();\n\t\t\t}));\n\t\t}, cb);\n\t});\n\tself.ensureIndex({_id: 1}, {name: '_id_', unique: true}, cb);\n};\n\ntcoll.prototype.initFS = function (tdb, name, options, create, cb) {\n\tvar self= this;\n\tthis._tdb = tdb;\n\tthis._cache = new tcache(tdb, tdb._gopts.cacheSize);\n\tthis._cmaxobj = tdb._gopts.cacheMaxObjSize || 1024;\n\tthis.collectionName = this._name = name;\n\tthis._filename = path.join(this._tdb._path, this._name);\n\tif (options.strict) {\n\t\tvar exists = fs.existsSync(self._filename);\n\t\tif (exists && create) return cb(new Error(\"Collection \" + self._name + \" already exists. Currently in safe mode.\"));\n\t\telse if (!exists && !create) return cb(new Error(\"Collection \" + self._name + \" does not exist. Currently in safe mode.\"));\n\t}\n\tvar pos = 0;\n\tvar deleted = 0;\n\tvar found = 0;\n\tthis._tq = new wqueue(100, function (cb) {\n\t\tsafe.run(function (cb) {\n\t\t\tfs.open(self._filename, \"a+\", safe.sure(cb, function (fd) {\n\t\t\tself._fd = fd;\n\t\t\tvar b1 = new Buffer(45);\n\t\t\tsafe.whilst(function () { return self._fsize === null; }, function(cb) {\n\t\t\t\tsafe.run(function (cb) {\n\t\t\t\t\tfs.read(fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {\n\t\t\t\t\t\tif (bytes===0) {\n\t\t\t\t\t\t\tself._fsize = pos;\n\t\t\t\t\t\t\treturn cb();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar h1 = JSON.parse(data.toString());\n\t\t\t\t\t\th1.o = parseInt(h1.o,10);\n\t\t\t\t\t\th1.k = parseInt(h1.k,10);\n\t\t\t\t\t\tvar b2 = new Buffer(h1.k);\n\t\t\t\t\t\tfs.read(fd,b2,0,h1.k,pos+45+1, safe.sure(cb, function (bytes, data) {\n\t\t\t\t\t\t\tvar k = JSON.parse(data.toString());\n\t\t\t\t\t\t\tself._id = k._uid;\n\t\t\t\t\t\t\tif (k._a=='del') {\n\t\t\t\t\t\t\t\tdelete self._store[k._id];\n\t\t\t\t\t\t\t\tdeleted++;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (self._store[k._id]) deleted++;\n\t\t\t\t\t\t\t\tself._store[k._id] = { pos: pos, sum: k._s };\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpos+=45+3+h1.o+h1.k;\n\t\t\t\t\t\t\tfound++;\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t}));\n\t\t\t\t\t}));\n\t\t\t\t}, function (err) {\n\t\t\t\t\tif (err)\n\t\t\t\t\t\tcb(new Error(self._name+\": Error during load - \"+err.toString()));\n\t\t\t\t\telse\n\t\t\t\t\t\tcb();\n\t\t\t\t});\n\t\t\t}, cb);\n\t\t\t}));\n\t\t}, function (err) {\n\t\t\tif (!found && err)\n\t\t\t\treturn cb(err); // nothing read and error, just rise it\n\n\t\t\tsafe.run(function (cb) {\n\t\t\t\tvar size = _.size(self._store);\n\t\t\t\t// autocompact on certain ratio or err\n\t\t\t\tif (deleted > size || err) {\n\t\t\t\t\tself._compact(function (errCompact) {\n\t\t\t\t\t\tif (errCompact && err)\n\t\t\t\t\t\t\tcb(errCompact);\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif (errCompact) console.log(err);\n\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else cb();\n\t\t\t}, function () {\n\t\t\t\tself._refreshIndexes(cb);\n\t\t\t});\n\t\t});\n\t});\n\tself.ensureIndex({_id: 1}, {name: '_id_', unique: true}, cb);\n};\n\ntcoll.prototype.compactCollection = function (cb) {\n\tvar self = this;\n\tself._tq.add(function (cb) {\n\t\tself._compact(safe.sure(cb, function () {\n\t\t\tself._cache.clear();\n\t\t\tself._refreshIndexes(cb);\n\t\t}));\n\t}, true, cb);\n};\n\ntcoll.prototype._refreshIndexes = function (cb) {\n\tvar self = this;\n\t_.each(self._idx,function(v, k) {\n\t\tv.clear();\n\t});\n\tsafe.eachOfSeries(self._store, function (rec, k, cb) {\n\t\tself._get(rec.pos, false, safe.sure(cb, function (obj) {\n\t\t\tvar id = simplifyKey(obj._id);\n\t\t\t_.each(self._idx,function(v, k) {\n\t\t\t\tv.set(obj, id);\n\t\t\t});\n\t\t\tcb();\n\t\t}));\n\t}, cb);\n};\n\ntcoll.prototype._compact = function (cb) {\n\tvar self = this;\n\tvar filename = self._filename + '.compact';\n\tfs.open(filename, 'w+', safe.sure(cb, function (fd) {\n\t\tvar b1 = new Buffer(45);\n\t\tfunction get(pos, cb) {\n\t\t\tfs.read(self._fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {\n\t\t\t\tvar h1 = JSON.parse(data.toString());\n\t\t\t\th1.o = parseInt(h1.o, 10);\n\t\t\t\th1.k = parseInt(h1.k, 10);\n\t\t\t\tvar b2 = new Buffer(h1.k + h1.o + 3);\n\t\t\t\tfs.read(self._fd, b2, 0, b2.length, pos + 45, safe.sure(cb, function (bytes, data) {\n\t\t\t\t\tcb(null, Buffer.concat([ b1, b2 ]));\n\t\t\t\t}));\n\t\t\t}));\n\t\t}\n\t\tvar wpos = 0;\n\t\tvar store = Object.create ? Object.create(null) : {};\n\t\tsafe.eachOfSeries(self._store, function (rec, k, cb) {\n\t\t\tget(rec.pos, safe.sure(cb, function (data) {\n\t\t\t\tfs.write(fd, data, 0, data.length, wpos, safe.sure(cb, function (written) {\n\t\t\t\t\tif (written != data.length) return cb(new Error('Insufficient disk space'));\n\t\t\t\t\tstore[k] = { pos: wpos, sum: rec.sum };\n\t\t\t\t\twpos += data.length;\n\t\t\t\t\tcb();\n\t\t\t\t}));\n\t\t\t}));\n\t\t}, function (err) {\n\t\t\tif (err) {\n\t\t\t\tfs.close(fd, function () {\n\t\t\t\t\tfs.unlink(filename, function () {\n\t\t\t\t\t\tcb(err);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!!process.platform.match(/^win/)) {\n\t\t\t\t// WINDOWS: unsafe because if something fail while renaming file it will not\n\t\t\t\t// restore automatically\n\t\t\t\tfs.close(self._fd, safe.sure(cb,function() {\n\t\t\t\t\tfs.close(fd, safe.sure(cb,function() {\n\t\t\t\t\t\tfs.unlink(self._filename, safe.sure(cb,function () {\n\t\t\t\t\t\t\tfs.rename(filename, self._filename, safe.sure(cb, function () {\n\t\t\t\t\t\t\t\tfs.open(self._filename, 'a+', safe.sure(cb, function (fd) {\n\t\t\t\t\t\t\t\t\tself._fd = fd;\n\t\t\t\t\t\t\t\t\tself._fsize = wpos;\n\t\t\t\t\t\t\t\t\tself._store = store;\n\t\t\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t\t}));\n\t\t\t\t\t\t}));\n\t\t\t\t\t}));\n\t\t\t\t}));\n\t\t    } else {\n\t\t\t\t// safe way\n\t\t\t\tfs.rename(filename, self._filename, safe.sure(cb, function () {\n\t\t\t\t\tfs.close(self._fd);\n\t\t\t\t\tself._fd = fd;\n\t\t\t\t\tself._fsize = wpos;\n\t\t\t\t\tself._store = store;\n\t\t\t\t\tcb();\n\t\t\t\t}));\n\t\t\t}\n\t\t});\n\t}));\n};\n\ntcoll.prototype.drop = function (cb) {\n\tthis._tdb.dropCollection(this._name,cb);\n};\n\ntcoll.prototype.rename = function (nname, opts, cb) {\n\tvar self = this;\n\tif (_.isFunction(opts)) {\n\t\tcb = opts;\n\t\topts = {};\n\t}\n\tvar err = self._tdb._nameCheck(nname);\n\tif (err)\n\t\treturn safe.back(cb,err);\n\tif (self._tdb._stype==\"mem\") {\n\t\tdelete self._tdb._cols[self._name];\n\t\tself._tdb._cols[nname] = self;\n\t\tdelete self._tdb._mstore[self._name];\n\t\tself._tdb._mstore[nname] = self._mstore;\n\t\tsafe.back(cb,null);\n\t} else {\n\t\tself._tq.add(function (cb) {\n\t\t\tfs.rename(path.join(self._tdb._path,self._name),path.join(self._tdb._path,nname),safe.sure(cb, function () {\n\t\t\t\tdelete self._tdb._cols[self._name];\n\t\t\t\tself._tdb._cols[nname] = self;\n\t\t\t\tself.collectionName = self._name = nname;\n\t\t\t\tcb();\n\t\t\t}));\n\t\t},true,cb);\n\t}\n};\n\ntcoll.prototype._stop = function (cb) {\n\tvar self = this;\n\tself._tq.add(function (cb) {\n\t\t// this will prevent any tasks processed on this instance\n\t\tself._tq._stoped = true;\n\t\tif (self._fd) {\n\t\t\tfs.close(self._fd,safe.sure(cb, function () {\n\t\t\t\tcb(null,true);\n\t\t\t}));\n\t\t} else\n\t\t\tcb(null,false);\n\t},true,cb);\n};\n\ntcoll.prototype.createIndex = tcoll.prototype.ensureIndex = function (obj, options, cb) {\n\tvar self = this;\n\tif (_.isFunction(options)) {\n\t\tcb = options;\n\t\toptions = {};\n\t}\n\tcb = cb || function () {};\n\toptions = options || {};\n\n\tvar c = new tcursor(this,{},{},{});\n\tc.sort(obj);\n\tif (c._err)\n\t\treturn safe.back(cb,c._err);\n\tvar key = c._sort;\n\n\tif (key===null)\n\t\treturn safe.back(cb,new Error(\"No fields are specified\"));\n\n\tvar index = self._idx[key];\n\tif (index)\n\t\treturn safe.back(cb,null, index.name);\n\n\t// force array support when global option is set\n\tif (_.isUndefined(options._tiarr) && self._tdb._gopts.searchInArray)\n\t\toptions._tiarr = true;\n\n\tvar name = options.name || _.map(key, function (v) { return v[0] + '_' + v[1]; }).join('_');\n\tindex = new tindex(key, self, options, name);\n\n\tif (self._tq._tc==-1) {\n\t\t// if no operation is pending just register index\n\t\tself._idx[key] = index;\n\t\tsafe.back(cb, null, index.name);\n\t}\n\telse {\n\t\t// overwise register index operation\n\t\tthis._tq.add(function (cb) {\n\t\t\tvar range = _.values(self._store);\n\t\t\tsafe.forEachSeries(range, function (rec, cb) {\n\t\t\t\tself._get(rec.pos, false, safe.sure(cb, function (obj) {\n\t\t\t\t\tindex.set(obj,simplifyKey(obj._id));\n\t\t\t\t\tcb();\n\t\t\t\t}));\n\t\t\t}, safe.sure(cb, function () {\n\t\t\t\tself._idx[key] = index;\n\t\t\t\tcb();\n\t\t\t}));\n\t\t}, true, function (err) {\n\t\t\tif (err) cb(err);\n\t\t\telse cb(null, index.name);\n\t\t});\n\t}\n};\n\ntcoll.prototype.indexExists = function (idx, cb) {\n\tif (!_.isArray(idx))\n\t\tidx = [idx];\n\tvar i = _.intersection(idx,_(this._idx).values().map('name').value());\n\tcb(null,i.length == idx.length);\n};\n\ntcoll.prototype.indexes = function (cb) {\n\tvar self = this;\n\tthis._tq.add(function (cb) {\n\t\tcb(null, _.values(self._idx));\n\t},false,cb);\n};\n\ntcoll.prototype._getM = function (pos, unsafe, cb) {\n\tsafe.back(cb,null,unsafe?this._mstore[pos-1]:this._tdb._cloneDeep(this._mstore[pos-1]));\n};\n\ntcoll.prototype._getFS = function (pos, unsafe, cb) {\n\tvar self = this;\n\tvar cached = self._cache.get(pos,unsafe);\n\tif (cached)\n\t\treturn safe.back(cb,null,cached);\n\tvar b1 = new Buffer(45);\n\tfs.read(self._fd, b1, 0, 45, pos, safe.trap_sure(cb, function (bytes, data) {\n\t\tvar h1 = JSON.parse(data.toString());\n\t\th1.o = parseInt(h1.o,10);\n\t\th1.k = parseInt(h1.k,10);\n\t\tvar b2 = new Buffer(h1.o);\n\t\tfs.read(self._fd,b2,0,h1.o,pos+45+2+h1.k, safe.trap_sure(cb, function (bytes, data) {\n\t\t\tvar obj = self._unwrapTypes(JSON.parse(data.toString()));\n\t\t\tif (bytes <= self._cmaxobj)\n\t\t\t\tself._cache.set(pos, obj);\n\t\t\tcb(null,obj);\n\t\t}))\n\t}))\n}\n\ntcoll.prototype.insert = function (docs, opts, cb ) {\n\tvar self = this;\n\tif (_.isFunction(opts) && cb == null) {\n\t\tcb = opts;\n\t\topts = {};\n\t}\n\topts = opts || {};\n\tif (opts.w>0 && !_.isFunction(cb))\n\t\tthrow new Error(\"Callback is required for safe update\");\n\tcb = cb || function () {};\n\tif (!_.isArray(docs))\n\t\tdocs = [docs];\n\tthis._tq.add(function (cb) {\n\t\tsafe.forEachSeries(docs, function (doc, cb) {\n\t\t\tif (_.isUndefined(doc._id)) {\n\t\t\t\tdoc._id = new self._tdb.ObjectID();\n\t\t\t}\n\t\t\tself._put(doc, false, cb);\n\t\t}, safe.sure(cb, function () {\n\t\t\tcb(null, docs);\n\t\t}))\n\t}, true, cb)\n}\n\ntcoll.prototype._wrapTypes = function(obj) {\n\tvar self = this;\n\t_.each(obj, function (v,k) {\n\t\tif (_.isDate(v))\n\t\t\tobj[k] = {$wrap:\"$date\",v:v.valueOf(),h:v}\n\t\telse if (v instanceof self._tdb.ObjectID)\n\t\t\tobj[k] = {$wrap:\"$oid\",v:v.toJSON()}\n\t\telse if (v instanceof self._tdb.Binary)\n\t\t\tobj[k] = {$wrap: \"$bin\", v: v.toJSON()};\n\t\telse if (_.isObject(v))\n\t\t\tself._wrapTypes(v)\n\n\t})\n\treturn obj;\n}\n\ntcoll.prototype._ensureIds = function(obj) {\n\tvar self = this;\n\t_.each(obj, function (v,k) {\n\t\tif (k.length >0) {\n\t\t\tif (k[0]=='$')\n\t\t\t\tthrow new Error(\"key \"+k+\" must not start with '$'\");\n\t\t\tif (k.indexOf('.')!=-1)\n\t\t\t\tthrow new Error(\"key \"+k+\" must not contain '.'\");\n\t\t}\n\t\tif (_.isObject(v)) {\n\t\t\tif (v instanceof self._tdb.ObjectID) {\n\t\t\t\tif (v.id<0) {\n\t\t\t\t\tv._persist(++self._id)\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t\tself._ensureIds(v)\n\t\t}\n\t})\n\treturn obj;\n}\n\n\ntcoll.prototype._unwrapTypes = function(obj) {\n\tvar self = this;\n\t_.each(obj, function (v,k) {\n\t\tif (_.isObject(v)) {\n\t\t\tswitch (v.$wrap) {\n\t\t\t\tcase \"$date\": obj[k] = new Date(v.v); break;\n\t\t\t\tcase \"$oid\":\n\t\t\t\t\tvar oid = new self._tdb.ObjectID(v.v);\n\t\t\t\t\tobj[k]=oid;\n\t\t\t\tbreak;\n\t\t\t\tcase \"$bin\":\n\t\t\t\t\tvar bin = new self._tdb.Binary(new Buffer(v.v, 'base64'));\n\t\t\t\t\tobj[k] = bin;\n\t\t\t\tbreak;\n\t\t\t\tdefault: self._unwrapTypes(v);\n\t\t\t}\n\t\t}\n\t})\n\treturn obj;\n}\n\ntcoll.prototype._putM = function (item_, remove, cb) {\n\tvar item = this._tdb._cloneDeep(item_);\n\tvar self = this;\n\tself._wq.add(function (cb) {\n\t\tvar err = _.attempt(function () {\n\t\t\titem = self._ensureIds(item);\n\t\t});\n\t\tif (err) {\n\t\t\terr.errmsg = err.toString();\n\t\t\treturn cb(err);\n\t\t}\n\t\tif (_.isUndefined(item._id))\n\t\t\treturn cb(new Error(\"Invalid object key (_id)\"));\n\n\t\tvar key = {_id:simplifyKey(item._id)};\n\n\t\t// check index update\n\t\tif (item && !remove) {\n\t\t\terr = _.attempt(function () {\n\t\t\t\t_.each(self._idx,function(v,k) {\n\t\t\t\t\tv.set(item,key._id,true);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tif (err) {\n\t\t\t\terr.errmsg = err.toString();\n\t\t\t\treturn cb(err);\n\t\t\t}\n\t\t}\n\n\t\tif (remove) {\n\t\t\tself._mstore[self._store[key._id].pos-1]=null;\n\t\t\tdelete self._store[key._id];\n\t\t}\n\t\telse {\n\t\t\tif (self._store[key._id]) {\n\t\t\t\tself._mstore[self._store[key._id].pos-1] = item;\n\t\t\t} else {\n\t\t\t\tself._mstore.push(item);\n\t\t\t\tself._store[key._id] = {pos: self._mstore.length};\n\t\t\t}\n\t\t}\n\n\t\t// update index\n\t\t_.each(self._idx,function(v,k) {\n\t\t\tif (!remove)\n\t\t\t\tv.set(item,key._id);\n\t\t\telse\n\t\t\t\tv.del(item,key._id);\n\t\t})\n\t\tcb(null);\n\t}, true, cb);\n}\n\n\ntcoll.prototype._putFS = function (item, remove, cb) {\n\tvar self = this;\n\tself._wq.add(function (cb) {\n\t\tvar err = _.attempt(function () {\n\t\t\titem = self._ensureIds(item);\n\t\t});\n\t\tif (err) {\n\t\t\terr.errmsg = err.toString();\n\t\t\treturn cb(err);\n\t\t}\n\t\tif (_.isUndefined(item._id))\n\t\t\treturn cb(new Error(\"Invalid object key (_id)\"));\n\t\titem = self._wrapTypes(item);\n\t\tvar sobj = new Buffer(remove?\"\":JSON.stringify(item));\n\t\titem = self._unwrapTypes(item);\n\t\tvar key = {_id:simplifyKey(item._id),_uid:self._id,_dt:(new Date()).valueOf()};\n\t\tif (remove) key._a = \"del\";\n\t\telse {\n\t\t\tvar hash = crypto.createHash('md5');\n\t\t\thash.update(sobj, 'utf8');\n\t\t\tkey._s = hash.digest('hex');\n\t\t}\n\t\tvar skey = new Buffer(JSON.stringify(key));\n\t\tvar zeros = \"0000000000\";\n\t\tvar lobj = sobj.length.toString();\n\t\tvar lkey = skey.length.toString();\n\t\tlobj = zeros.substr(0,zeros.length - lobj.length)+lobj;\n\t\tlkey = zeros.substr(0,zeros.length - lkey.length)+lkey;\n\t\tvar h1={k:lkey,o:lobj,v:\"001\"};\n\t\tvar buf = new Buffer(JSON.stringify(h1)+\"\\n\"+skey+\"\\n\"+sobj+\"\\n\");\n\n\t\t// check index update\n\t\tif (item && !remove) {\n\t\t\terr = _.attempt(function () {\n\t\t\t\t_.each(self._idx,function(v,k) {\n\t\t\t\t\tv.set(item,key._id,true);\n\t\t\t\t})\n\t\t\t});\n\t\t\tif (err) {\n\t\t\t\terr.errmsg = err.toString();\n\t\t\t\treturn cb(err);\n\t\t\t}\n\t\t}\n\n\t\tsafe.run(function (cb) {\n\t\t\tvar rec = self._store[key._id];\n\t\t\tif (rec && rec.sum == key._s) return safe.back(cb);\n\t\t\tfs.write(self._fd, buf, 0, buf.length, self._fsize, safe.sure(cb, function (written) {\n\t\t\t\tif (remove)\n\t\t\t\t\tdelete self._store[key._id];\n\t\t\t\telse\n\t\t\t\t\tself._store[key._id] = { pos: self._fsize, sum: key._s };\n\n\t\t\t\tif (remove || sobj.length > self._cmaxobj)\n\t\t\t\t\tself._cache.unset(self._fsize)\n\t\t\t\telse\n\t\t\t\t\tself._cache.set(self._fsize,item);\n\t\t\t\tself._fsize+=written;\n\t\t\t\t// randomly check for non exclusive file usage\n\t\t\t\t// which is growth of file that we are nor aware\n\t\t\t\t// randomly to avoid overhead\n\t\t\t\tif (self._check1==0) {\n\t\t\t\t\tthis._check1 = Math.random()*100+1;\n\t\t\t\t\tfs.fstat(self._fd, safe.sure(cb, function (stat) {\n\t\t\t\t\t\tif (self._fsize!=stat.size)\n\t\t\t\t\t\t\tcb(new Error(\"File size mismatch. Are you use db/collection exclusively?\"))\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tcb()\n\t\t\t\t\t}))\n\t\t\t\t} else {\n\t\t\t\t\tself._check1--;\n\t\t\t\t\tcb();\n\t\t\t\t}\n\t\t\t}));\n\t\t},\n\t\tfunction () {\n\t\t\t// update index\n\t\t\t_.each(self._idx,function(v,k) {\n\t\t\t\tif (!remove)\n\t\t\t\t\tv.set(item,key._id);\n\t\t\t\telse\n\t\t\t\t\tv.del(item,key._id);\n\t\t\t})\n\t\t\tcb(null);\n\t\t});\n\t}, true, cb);\n}\n\ntcoll.prototype.count = function (query, options, cb) {\n\tvar self = this;\n\tif (arguments.length == 1) {\n\t\tcb = arguments[0];\n        options = null;\n\t\tquery = null;\n\t}\n\tif (arguments.length == 2) {\n        query = arguments[0];\n\t\tcb = arguments[1];\n        options = null;\n\t}\n\n\tif (query==null || _.size(query)==0) {\n\t\tthis._tq.add(function (cb) {\n\t\t\tcb(null, _.size(self._store));\n\t\t},false,cb);\n\t} else\n\t\tself.find(query, options).count(cb);\n};\n\ntcoll.prototype.stats = function (cb) {\n\tvar self = this;\n\tthis._tq.add(function (cb) {\n\t\tcb(null, {count:_.size(self._store)});\n\t},false,cb);\n}\n\n\nvar findOpts = ['limit','sort','fields','skip','hint','timeout','batchSize','safe','w'];\n\ntcoll.prototype.findOne = _.rest(function (args) {\n\tvar cb = args.pop();\n\tthis.find.apply(this,args).limit(1).nextObject(cb);\n});\n\ntcoll.prototype.find = function () {\n\tvar cb = null, query = {}, opts = {}, fields = null, skip = null, limit = null, sort = null;\n\tvar argc = arguments.length;\n\tif (argc>0) {\n\t\t// guess callback, it is always latest\n\t\tcb = arguments[argc-1];\n\t\tif (!_.isFunction(cb))\n\t\t\tcb=null\n\t\telse\n\t\t\targc--;\n\t\tif (argc>0) {\n\t\t\t// query should always exist\n\t\t\tquery = arguments[0]\n\t\t\tif (argc>1) {\n\t\t\t\tif (argc==2) {\n\t\t\t\t\tvar val = arguments[1];\n\t\t\t\t\t// worst case we get either options either fiels\n\t\t\t\t\tif (_(val).keys().intersection(findOpts).size() > 0)\n\t\t\t\t\t\topts = val\n\t\t\t\t\telse\n\t\t\t\t\t\tfields = val;\n\t\t\t\t} else {\n\t\t\t\t\tfields = arguments[1];\n\t\t\t\t\tif (argc == 3)\n\t\t\t\t\t\topts = arguments[2]\n\t\t\t\t\telse {\n\t\t\t\t\t\tskip = arguments[2];\n\t\t\t\t\t\tlimit = arguments[3]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\topts = opts || {};\n\tskip = skip || opts.skip || null;\n\tlimit = limit || opts.limit || null;\n\tfields = fields || opts.fields || null;\n\tsort = sort || opts.sort || null;\n\n\n\tvar c = new tcursor(this,query, fields, opts);\n\n\tif (skip) c.skip(skip);\n\tif (limit) c.limit(limit);\n\tif (sort) c.sort(sort);\n\tif (cb)\n\t\tcb(null, c)\n\telse\n\t\treturn c;\n}\n\n\nfunction simplifyKey(key) {\n\tvar k = key;\n\tif (key.toJSON)\n\t\tk = key.toJSON();\n\tif (_.isNumber(k)||_.isString(k))\n\t\treturn k;\n\treturn k.toString();\n}\n\ntcoll.prototype.update = function (query, doc, opts, cb) {\n\tvar self = this;\n\tif (_.isFunction(opts) && cb == null) {\n\t\tcb = opts;\n\t}\n\topts = opts || {};\n\tif (opts.w>0 && !_.isFunction(cb))\n\t\tthrow new Error(\"Callback is required for safe update\");\n\tcb = cb || function () {}\n\tif (!_.isObject(query))\n\t\tthrow new Error(\"selector must be a valid JavaScript object\");\n\tif (!_.isObject(doc))\n\t\tthrow new Error(\"document must be a valid JavaScript object\");\n\n\tvar multi = opts.multi || false;\n    var updater = new Updater(doc, self._tdb);\n\tvar $doc = updater.hasAtomic()?null:doc;\n\tthis._tq.add(function (cb) {\n\t\tself.__find(query, null, 0, multi ? null : 1, null, opts.hint, {}, safe.sure(cb, function (res) {\n\t\t\tif (res.length==0) {\n\t\t\t\tif (opts.upsert) {\n\t\t\t\t\t$doc = $doc || query;\n\t\t\t\t\t$doc = self._tdb._cloneDeep($doc);\n\t\t\t\t\tupdater.update($doc,true);\n\t\t\t\t\tif (_.isUndefined($doc._id))\n\t\t\t\t\t\t$doc._id = new self._tdb.ObjectID();\n\t\t\t\t\tself._put($doc, false, safe.sure(cb, function () {\n\t\t\t\t\t\tcb(null, 1,{updatedExisting:false,upserted:$doc._id,n:1})\n\t\t\t\t\t}))\n\t\t\t\t} else\n\t\t\t\t\tcb(null,0);\n\t\t\t} else {\n\t\t\t\tsafe.forEachSeries(res, function (pos, cb) {\n\t\t\t\t\tself._get(pos, false, safe.sure(cb, function (obj) {\n\t\t\t\t\t\t// remove current version of doc from indexes\n\t\t\t\t\t\t_.each(self._idx,function(v,k) {\n\t\t\t\t\t\t\tv.del(obj,simplifyKey(obj._id));\n\t\t\t\t\t\t})\n\t\t\t\t\t\tvar udoc = $doc;\n\t\t\t\t\t\tif (!$doc) {\n\t\t\t\t\t\t\tudoc = obj;\n\t\t\t\t\t\t\tupdater.update(udoc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tudoc._id = obj._id;\n\t\t\t\t\t\t// put will add it back to indexes\n\t\t\t\t\t\tself._put(udoc, false, cb);\n\t\t\t\t\t}))\n\t\t\t\t}, safe.sure(cb,function () {\n\t\t\t\t\tcb(null, res.length, {updatedExisting:true,n:res.length});\n\t\t\t\t}))\n\t\t\t}\n\t\t}))\n\t},true,cb);\n}\n\ntcoll.prototype.findAndModify = function (query, sort, doc, opts, cb) {\n\tvar self = this;\n\tif (_.isFunction(opts) && cb == null) {\n\t\tcb = opts;\n\t\topts = {};\n\t}\n\topts = opts || {};\n\tdoc = doc || {};\n\n\tvar updater = new Updater(doc, self._tdb);\n\tvar $doc = updater.hasAtomic()?null:doc;\n\n\tvar c = new tcursor(this,{}, opts.fields || {},{});\n\tc.sort(sort);\n\tif (c._err)\n\t\treturn safe.back(cb,c._err);\n\n\tthis._tq.add(function (cb) {\n\t\tself.__find(query, null, 0, 1, c._sort, opts.hint, {}, safe.sure(cb, function (res) {\n\t\t\tif (res.length==0) {\n\t\t\t\tif (opts.upsert) {\n\t\t\t\t\t$doc = $doc || query;\n\t\t\t\t\t$doc = self._tdb._cloneDeep($doc);\n\t\t\t\t\tupdater.update($doc,true);\n\t\t\t\t\tif (_.isUndefined($doc._id))\n\t\t\t\t\t\t$doc._id = new self._tdb.ObjectID();\n\t\t\t\t\tself._put($doc, false, safe.sure(cb, function () {\n\t\t\t\t\t\tcb(null,opts.new?c._projectFields($doc):{})\n\t\t\t\t\t}))\n\t\t\t\t} else\n\t\t\t\t\tcb();\n\t\t\t} else {\n\t\t\t\tself._get(res[0], false, safe.sure(cb, function (obj) {\n\t\t\t\t\tvar robj = (opts.new && !opts.remove) ? obj : self._tdb._cloneDeep(obj);\n\t\t\t\t\t// remove current version of doc from indexes\n\t\t\t\t\t_.each(self._idx,function(v,k) {\n\t\t\t\t\t\tv.del(obj,simplifyKey(obj._id));\n\t\t\t\t\t})\n\t\t\t\t\tvar udoc = $doc;\n\t\t\t\t\tif (!$doc) {\n\t\t\t\t\t\tudoc = obj;\n\t\t\t\t\t\tupdater.update(udoc);\n\t\t\t\t\t}\n\t\t\t\t\tudoc._id = obj._id;\n\t\t\t\t\t// put will add it back to indexes\n\t\t\t\t\tself._put(udoc, opts.remove?true:false, safe.sure(cb,function () {\n\t\t\t\t\t\tcb(null,c._projectFields(robj))\n\t\t\t\t\t}))\n\t\t\t\t}))\n\t\t\t}\n\t\t}))\n\t},true,cb);\n}\n\ntcoll.prototype.save = function (doc, opts, cb) {\n\tvar self = this;\n\tcb = _.isFunction(doc)?doc:_.isFunction(opts)?opts:cb;\n\tcb = cb || function () {};\n\tdoc = doc || {};\n\topts = opts || {};\n\tthis._tq.add(function (cb) {\n\t\tvar res = doc;\n\t\t(function(cb) {\n\t\t\tif (_.isUndefined(doc._id)) {\n\t\t\t\tdoc._id = new self._tdb.ObjectID();\n\t\t\t\tcb()\n\t\t\t} else {\n\t\t\t\tvar id = simplifyKey(doc._id);\n\t\t\t\tvar pos = self._store[id];\n\t\t\t\t// check if document with this id already exist\n\t\t\t\tif (pos) {\n\t\t\t\t\t// if so we need to fetch it to update index\n\t\t\t\t\tself._get(pos.pos, false, safe.sure(cb, function (oldDoc) {\n\t\t\t\t\t\t// remove current version of doc from indexes\n\t\t\t\t\t\t_.each(self._idx,function(v,k) {\n\t\t\t\t\t\t\tv.del(oldDoc,id);\n\t\t\t\t\t\t})\n\t\t\t\t\t\tres = 1;\n\t\t\t\t\t\tcb();\n\t\t\t\t\t}))\n\t\t\t\t} else cb();\n\t\t\t}\n\t\t})(safe.sure(cb, function () {\n\t\t\tself._put(doc, false, safe.sure(cb, function () {\n\t\t\t\tcb(null,res); // when update return 1 when new save return obj\n\t\t\t}))\n\t\t}))\n\t},true,cb);\n}\n\ntcoll.prototype.remove = function (query, opts, cb) {\n\tvar self = this;\n\tif (_.isFunction(query)) {\n\t\tcb = query;\n\t\tquery = opts = {};\n\t} else if (_.isFunction(opts)) {\n\t\tcb = opts;\n\t\topts = {};\n\t}\n\topts = opts || {};\n\tif (opts.w>0 && !_.isFunction(cb))\n\t\tthrow new Error(\"Callback is required\");\n\tcb = cb || function () {};\n\tvar single = opts.single || false;\n\tthis._tq.add(function (cb) {\n\t\tself.__find(query, null, 0, single ? 1 : null, null, opts.hint, {}, safe.sure(cb, function (res) {\n\t\t\tsafe.forEachSeries(res, function (pos, cb) {\n\t\t\t\tself._get(pos, false, safe.sure(cb, function (obj) {\n\t\t\t\t\tself._put(obj,true,cb);\n\t\t\t\t}))\n\t\t\t}, safe.sure(cb, function () {\n\t\t\t\tcb(null,res.length);\n\t\t\t}))\n\t\t}))\n\t},true,cb);\n}\n\ntcoll.prototype.findAndRemove = function (query,sort,opts,cb) {\n\tvar self = this;\n\n\tif (_.isFunction(sort) && cb == null && opts==null) {\n\t\tcb = sort;\n\t\tsort = {}\n\t\topts = {};\n\t} else if (_.isFunction(opts) && cb == null) {\n\t\tcb = opts;\n\t\topts = {};\n\t}\n\topts = opts || {};\n\tsort = sort || {};\n\n\tvar c = new tcursor(this,{},{},{});\n\n\t// Fix for mongoouse/tungus they pass sort as undefined\n\tc.sort(sort);\n\n\tif (c._err)\n\t\treturn safe.back(cb,c._err);\n\n\tthis._tq.add(function (cb) {\n\t\tself.__find(query, null, 0, 1, c._sort, opts.hint, {}, safe.sure(cb, function (res) {\n\t\t\tif (res.length==0)\n\t\t\t\treturn cb();\n\t\t\tself._get(res[0], false, safe.sure(cb, function (obj) {\n\t\t\t\tself._put(obj,true,safe.sure(cb, function () {\n\t\t\t\t\tcb(null,obj);\n\t\t\t\t}))\n\t\t\t}))\n\t\t}))\n\t},true,cb);\n}\n\ntcoll.prototype._bestSortIndex = function (sort) {\n\t// no sort\n\tif (!sort) return null;\n\t// exact match\n\tif (this._idx[sort]) return this._idx[sort];\n\t// find potential sort indexes\n\tvar pi = [];\n\t_.each(this._idx,function (idx) {\n\t\tvar fields = idx.fields();\n\t\tvar match = _.takeWhile(fields, function (kv, i) {\n\t\t\treturn i < sort.length ? kv[0] == sort[i][0] : false;\n\t\t});\n\t\tif (match.length == sort.length) {\n\t\t\tvar score = fields.length;\n\t\t\t_.each(sort,function (kv, i) {\n\t\t\t\tif (kv[1] != fields[i][1]) score += 1;\n\t\t\t});\n\t\t\tpi.push({ value: idx, score: score });\n\t\t}\n\t});\n\tif (pi.length === 0) return null;\n\t// select best index\n\tpi = pi.sort(function (l, r) { return l.score < r.score; });\n\treturn pi[0].value;\n};\n\nfunction reduceIndexSet(pi) {\n\tvar hit;\n\tdo {\n\t\thit = false;\n\t\t// compare each potential index with each other\n\t\t_.each(pi,function (v1, i1) {\n\t\t\t_.each(pi,function (v2, i2) {\n\t\t\t\tif (i1 == i2) return;\n\t\t\t\t// compare the set of possible keys for both indexes\n\t\t\t\tif (_.union(v1.k, v2.k).length == v1.k.length) {\n\t\t\t\t\t// key for v2 is a subset of key for v1, check equality\n\t\t\t\t\tif (v1.k.length == v2.k.length && v1.i.depth() > v2.i.depth()) {\n\t\t\t\t\t\t// keys are equal, but the depth of v2 is lower;\n\t\t\t\t\t\t// v2 is preferable, strike out v1\n\t\t\t\t\t\tpi.splice(i1, 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// in other two cases v1 is preferable, strike out v2\n\t\t\t\t\t\tpi.splice(i2, 1);\n\t\t\t\t\t}\n\t\t\t\t\thit = true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t});\n\t\t\tif (hit) return false;\n\t\t});\n\t} while (hit);\n}\n\ntcoll.prototype.__find = function (query, fields, skip, limit, sort, hint, arFields, cb) {\n\tvar self = this;\n\tvar range;\n\t// find sort index\n\tvar si = this._bestSortIndex(sort);\n\t// for non empty query check indexes that we can use\n\tvar qt = self._tdb.Finder.matcher(query);\n\tvar pi = [];\n\tif (_.size(qt)>0) {\n\t\t_.each(self._idx,function (i) {\n\t\t\tvar f = _.map(i.fields(), 0);\n\t\t\tvar e = _.takeWhile(f, function (k) {\n\t\t\t\treturn qt._ex(k) == 1 && (!hint || hint[k]);\n\t\t\t});\n\t\t\tif (e.length > 0) pi.push({ i: i, k: e, e: f.length > e.length });\n\t\t});\n\t}\n\n\t// if possible indexes found split the query and process\n\t// indexes separately\n\tif (!_.isEmpty(pi)) {\n\t\t// choose the most appropriate indexes\n\t\treduceIndexSet(pi);\n\t\t// split query\n\t\tvar io = {};\n\t\t_.each(pi,function (v) {\n\t\t\t_.each(v.k,function (k) {\n\t\t\t\tif (!io[k]) io[k] = qt.split(k);\n\t\t\t});\n\t\t});\n\t\t// process indexes\n\t\tvar p = _.map(pi,function (st) {\n\t\t\t// this action applies to all indexes\n\t\t\tvar r = io[st.k[0]]._index(st.i);\n\t\t\t// process subfields of compound index\n\t\t\t_.each(st.k.slice(1),function (k) {\n\t\t\t\tvar v = io[k];\n\t\t\t\tr = _(r).map(function (si) { return v._index(si); }).flatten().value();\n\t\t\t});\n\t\t\t// expand subindexes to plain ids\n\t\t\tif (st.e) r = _(r).map(function (si) { return si.all(); }).flatten().value();\n\t\t\t// store result of index search\n\t\t\treturn r;\n\t\t});\n\t\tif (p.length == 1) {\n\t\t\tp = p[0];\n\t\t\t// optimization for the case when search and sorting indexes are the same\n\t\t\tif (si && pi[0].i === si) {\n\t\t\t\tvar sif = si.fields();\n\t\t\t\tif (_.every(sort, function (v, i) { return sif[i][1] == v[1]; })) {\n\t\t\t\t\t// sort order exactly matches index order,\n\t\t\t\t\t// so the result is already sorted\n\t\t\t\t\tsort = null;\n\t\t\t\t} else if (_.every(sort, function (v, i) { return sif[i][1] == -v[1]; })) {\n\t\t\t\t\t// sort order is exactly opposite to index order,\n\t\t\t\t\t// so the result is sorted, but in reverse direction\n\t\t\t\t\tp.reverse();\n\t\t\t\t\tsort = null;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t// TODO: use sort index as intersect base to speedup sorting\n\t\t\tp = tutils.intersectIndexes(p);\n\t\t}\n\t\t// nowe we have ids, need to convert them to positions\n\t\trange = _.map(p,function (_id) {\n\t\t\treturn self._store[_id].pos;\n\t\t})\n\t} else {\n\t\tif (si) {\n\t\t\trange = _.map(si.all(_.map(sort, 1)), function (_id) {\n\t\t\t\treturn self._store[_id].pos;\n\t\t\t})\n\t\t\t//if (order==-1)\n\t\t\t//\trange.reverse();\n\t\t\tsort = null;\n\t\t} else\n\t\t\trange = _(self._store).values().map('pos').value();\n\t}\n\n\tif (sort && si) {\n\t\tvar ps = {};\n\t\t_.each(range, function (pos) {\n\t\t\tps[pos] = true;\n\t\t});\n\t\trange = [];\n\t\t_.each(si.all(_.map(sort, 1)), function (_id) {\n\t\t\tvar pos = self._store[_id].pos;\n\t\t\tif (_.has(ps, pos))\n\t\t\t\trange.push(pos);\n\t\t});\n\t\t//if (order == -1)\n\t\t//\trange.reverse();\n\t\tsort = null;\n\t}\n\n\t// no sort, no query then return right away\n\tif (sort==null && (_.size(qt)==0 || qt._args.length==0)) {\n\t\tif (skip!=0 || limit!=null) {\n\t\t\tvar c = Math.min(range.length-skip,limit?limit:range.length-skip);\n\t\t\trange = range.splice(skip,c)\n\t\t}\n\t\treturn safe.back(cb,null,range);\n\t}\n\n\t// check if we can use simple match or array match function\n\tvar arrayMatch = false;\n\tif (self._tdb._gopts.searchInArray)\n\t\tarrayMatch = true;\n\telse {\n\t\t_.each(qt.fields(), function (v,k) {\n\t\t\tif (_.get(arFields, k)) {\n\t\t\t\tarrayMatch = true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t})\n\t}\n\n\tvar matcher = new Function(\"obj\", \"return \" + (arrayMatch ? qt.native3() : qt.native()));\n\n\t// create sort index\n\tif (sort) {\n\t\tsi = new tindex(sort,self);\n\t}\n\n\t// now simple non-index search\n\tvar res = [];\n\tvar found = 0;\n\tsafe.forEachSeries(range, function (pos, cb) {\n\t\tif (sort==null && limit && res.length>=limit)\n\t\t\treturn safe.back(cb);\n\t\tself._get(pos, true, safe.sure(cb, function (obj) {\n\t\t\tif (matcher(obj)) {\n\t\t\t\tif (sort!=null || found>=skip) {\n\t\t\t\t\tif (sort==null)\n\t\t\t\t\t\tres.push(pos);\n\t\t\t\t\telse\n\t\t\t\t\t\tsi.set(obj,pos);\n\t\t\t\t}\n\t\t\t\tfound++;\n\t\t\t}\n\t\t\tcb()\n\t\t}))\n\t}, safe.sure(cb, function () {\n\t\tif (sort) {\n\t\t\tres = si.all();\n\t\t\t//if (order==-1) {\n\t\t\t//\tres.reverse();\n\t\t\t//}\n\t\t\tif (skip!=0 || limit!=null) {\n\t\t\t\tvar c = Math.min(res.length-skip,limit?limit:res.length-skip);\n\t\t\t\tres = res.splice(skip,c)\n\t\t\t}\n\t\t}\n\t\tcb(null, res);\n\t}))\n}\n\ntcoll.prototype._find = function (query, fields, skip, limit, sort_, hint, arFields, cb) {\n\tvar self = this;\n\tthis._tq.add(function (cb) {\n\t\tself.__find(query, fields, skip, limit, sort_, hint, arFields, cb);\n\t}, false, cb);\n}\n\nfunction code2fn(obj) {\n\tif (_.isObject(obj)) {\n\t\t_.each(obj,function (value, key) {\n\t\t\tif (value instanceof Code) {\n\t\t\t\twith (value.scope) {\n\t\t\t\t\tobj[key] = eval('(' + value.code + ')');\n\t\t\t\t}\n\t\t\t}\n\t\t\telse code2fn(value);\n\t\t});\n\t}\n}\n\ntcoll.prototype.mapReduce = function (map, reduce, opts, cb) {\n\tvar self = this;\n\tif (_.isFunction(opts)) {\n\t\tcb = opts;\n\t\topts = {};\n\t}\n\n\tif (!opts.out) return safe.back(cb, new Error('the out option parameter must be defined'));\n\tif (!opts.out.inline && !opts.out.replace) {\n\t\treturn safe.back(cb, new Error('the only supported out options are inline and replace'));\n\t}\n\n\tcode2fn(opts.scope);\n\n\tvar m = {};\n\n\tfunction emit(k, v) {\n\t\tvar values = m[k];\n\t\tif (!values) m[k] = [ v ];\n\t\telse {\n\t\t\tvalues.push(v);\n\t\t\tif (values.length > 1000) values = [ reduce(k, values) ];\n\t\t}\n\t}\n\n\twith (opts.scope || {}) {\n\t\ttry {\n\t\t\tif (map instanceof Code) {\n\t\t\t\twith (map.scope) {\n\t\t\t\t\tmap = eval('(' + map.code + ')');\n\t\t\t\t}\n\t\t\t} else map = eval('(' + map + ')');\n\t\t\tif (reduce instanceof Code) {\n\t\t\t\twith (reduce.scope) {\n\t\t\t\t\treduce = eval('(' + reduce.code + ')');\n\t\t\t\t}\n\t\t\t} else reduce = eval('(' + reduce + ')');\n\t\t\tif (finalize instanceof Code) {\n\t\t\t\twith (finalize.scope) {\n\t\t\t\t\tfinalize = eval('(' + finalize.code + ')');\n\t\t\t\t}\n\t\t\t} else var finalize = eval('(' + opts.finalize + ')');\n\t\t} catch (e) {\n\t\t\treturn safe.back(cb,e);\n\t\t}\n\t}\n\n\tself.find(opts.query, null, { limit: opts.limit, sort: opts.sort }, safe.sure(cb, function (c) {\n\t\tvar doc;\n\t\tsafe.doUntil(\n\t\t\tfunction (cb) {\n\t\t\t\tc.nextObject(safe.trap_sure(cb, function (_doc) {\n\t\t\t\t\tdoc = _doc;\n\t\t\t\t\tif (doc) map.call(doc);\n\t\t\t\t\treturn cb();\n\t\t\t\t}));\n\t\t\t},\n\t\t\tfunction () {\n\t\t\t\treturn doc === null;\n\t\t\t},\n\t\t\tsafe.trap_sure(cb, function () {\n\t\t\t\t_.each(m,function (v, k) {\n\t\t\t\t\tv = v.length > 1 ? reduce(k, v) : v[0];\n\t\t\t\t\tif (finalize) v = finalize(k, v);\n\t\t\t\t\tm[k] = v;\n\t\t\t\t});\n\n\t\t\t\tvar stats = {};\n\t\t\t\tif (opts.out.inline) return process.nextTick(function () {\n\t\t\t\t\tcb(null, _.values(m), stats); // execute outside of trap\n\t\t\t\t});\n\n\t\t\t\t// write results to collection\n\t\t\t\tsafe.waterfall([\n\t\t\t\t\tfunction (cb) {\n\t\t\t\t\t\tself._tdb.collection(opts.out.replace, { strict: 1 }, function (err, col) {\n\t\t\t\t\t\t\tif (err) return cb(null, null);\n\t\t\t\t\t\t\tcol.drop(cb);\n\t\t\t\t\t\t});\n\t\t\t\t\t},\n\t\t\t\t\tfunction (arg, cb) {\n\t\t\t\t\t\tself._tdb.collection(opts.out.replace, {}, cb);\n\t\t\t\t\t},\n\t\t\t\t\tfunction (col, cb) {\n\t\t\t\t\t\tvar docs = _.map(m, function (value, key) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\t_id: key,\n\t\t\t\t\t\t\t\tvalue: value\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcol.insert(docs, safe.sure(cb, function () {\n\t\t\t\t\t\t\tif (opts.verbose) cb(null, col, stats);\n\t\t\t\t\t\t\telse cb(null, col);\n\t\t\t\t\t\t}));\n\t\t\t\t\t}\n\t\t\t\t], cb);\n\t\t\t}\n\t\t)); // doUntil\n\t}));\n};\n\ntcoll.prototype.group = _.rest(function (keys, condition, initial, args) {\n\tvar self = this;\n\n\tvar callback = args.pop(),\n\t\treduce = args.length ? args.shift() : null,\n\t\tfinalize = args.length ? args.shift() : null,\n\t\tcommand = args.length ? args.shift() : null,\n\t\toptions = args.length ? args.shift() : {};\n\n\tif (!_.isFunction(finalize)) {\n\t\tcommand = finalize;\n\t\tfinalize = null;\n\t}\n\n\tcode2fn(options.scope);\n\n\twith (options.scope || {}) {\n\t\ttry {\n\t\t\tif (_.isFunction(keys)) keys = eval('(' + keys + ')');\n\t\t\telse if (keys instanceof Code) {\n\t\t\t\twith (keys.scope) {\n\t\t\t\t\tkeys = eval('(' + keys.code + ')');\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (reduce instanceof Code) {\n\t\t\t\twith (reduce.scope) {\n\t\t\t\t\treduce = eval('(' + reduce.code + ')');\n\t\t\t\t}\n\t\t\t} else reduce = eval('(' + reduce + ')');\n\t\t\tif (finalize instanceof Code) {\n\t\t\t\twith (finalize.scope) {\n\t\t\t\t\tfinalize = eval('(' + finalize.code + ')');\n\t\t\t\t}\n\t\t\t} else finalize = eval('(' + finalize + ')');\n\t\t} catch (e) {\n\t\t\treturn callback(e);\n\t\t}\n\t}\n\n\tvar m = {};\n\tself.find(condition, safe.sure(callback, function (c) {\n\t\tvar doc;\n\t\tsafe.doUntil(\n\t\t\tfunction (cb) {\n\t\t\t\tc.nextObject(safe.sure(cb, function (_doc) {\n\t\t\t\t\tdoc = _doc;\n\t\t\t\t\tif (!doc) return cb();\n\t\t\t\t\tvar keys2 = keys;\n\t\t\t\t\tif (_.isFunction(keys)) keys2 = keys(doc);\n\t\t\t\t\tif (!_.isArray(keys2)) {\n\t\t\t\t\t\tvar keys3 = [];\n\t\t\t\t\t\t_.each(keys2,function (v, k) {\n\t\t\t\t\t\t\tif (v) keys3.push(k);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tkeys2 = keys3;\n\t\t\t\t\t}\n\t\t\t\t\tvar key = {};\n\t\t\t\t\t_.each(keys2,function (k) {\n\t\t\t\t\t\tkey[k] = doc[k];\n\t\t\t\t\t});\n\t\t\t\t\tvar skey = JSON.stringify(key);\n\t\t\t\t\tvar obj = m[skey];\n\t\t\t\t\tif (!obj) obj = m[skey] = _.extend({}, key, initial);\n\t\t\t\t\ttry {\n\t\t\t\t\t\treduce(doc, obj);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\treturn cb(e);\n\t\t\t\t\t}\n\t\t\t\t\tcb();\n\t\t\t\t}));\n\t\t\t},\n\t\t\tfunction () {\n\t\t\t\treturn doc === null;\n\t\t\t},\n\t\t\tsafe.sure(callback, function () {\n\t\t\t\tvar result = _.values(m);\n\t\t\t\tif (finalize) {\n\t\t\t\t\t_.each(result,function (value) {\n\t\t\t\t\t\tfinalize(value);\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tcallback(null, result);\n\t\t\t})\n\t\t);\n\t}));\n});\n","/home/travis/build/npmtest/node-npmtest-tingodb/node_modules/tingodb/lib/tcursor.js":"var safe = require('safe');\nvar _ = require('lodash');\nvar CursorStream = require('./tstream');\n\nfunction tcursor (tcoll,query,fields,opts) {\n\tvar self = this;\n\tthis.INIT = 0;\n\tthis.OPEN = 1;\n\tthis.CLOSED = 2;\n\tthis.GET_MORE = 3;\n\tthis._query = query;\n\tthis._c = tcoll;\n\tthis._i = 0;\n\tthis._skip = 0;\n\tthis._limit = null;\n\tthis._count = null;\n\tthis._items = null;\n\tthis._sort = null;\n\tthis._hint = opts.hint;\n\tthis._arFields = Object.create ? Object.create(null) : {};\n\tthis._fieldsType = null;\n\tthis._fieldsExcludeId = false;\n\tthis._fields = Object.create ? Object.create(null) : {};\n\tthis.timeout = _.isUndefined(opts.timeout)?true:opts.timeout;\n\n\t_.each(fields, function (v,k) {\n\t\tif (!k && _.isString(v)) {\n\t\t\tk=v; v = 1;\n\t\t}\n\t\tif (v == 0 || v==1) {\n\t\t\t// _id treated specially\n\t\t\tif (k==\"_id\" && v==0) {\n\t\t\t\tself._fieldsExcludeId = true;\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (self._fieldsType==null)\n\t\t\t\tself._fieldsType = v;\n\t\t\tif (self._fieldsType==v) {\n\t\t\t\tif (k.indexOf(\"_tiar.\")==0)\n\t\t\t\t\tself._arFields[k.substr(6)]=1;\n\t\t\t\telse\n\t\t\t\t\tself._fields[k]=v;\n\t\t\t} else if (!self._err)\n\t\t\t\tself._err = new Error(\"Mixed set of projection options (0,1) is not valid\");\n\t\t} else if (!self._err)\n\t\t\tself._err = new Error(\"Unsupported projection option: \"+JSON.stringify(v));\n\t})\n\t// _id treated specially\n\tif ((self._fieldsType===0 || self._fieldsType===null) && self._fieldsExcludeId) {\n\t\tself._fieldsType = 0;\n\t\tself._fields['_id']=0;\n\t}\n}\n\nfunction applyProjectionDel(obj,$set) {\n\t_.each($set, function (v,k) {\n\t\tvar path = k.split(\".\")\n\t\tvar t = null;\n\t\tif (path.length==1)\n\t\t\tt = obj\n\t\telse {\n\t\t\tvar l = obj;\n\t\t\tfor (var i=0; i<path.length-1; i++) {\n\t\t\t\tvar p = path[i];\n\t\t\t\tif (l[p]==null)\n\t\t\t\t\tbreak;\n\t\t\t\tl = l[p];\n\t\t\t}\n\t\t\tt = i==path.length-1?l:null;\n\t\t\tk = path[i];\n\t\t}\n\t\tif (t)\n\t\t\tdelete t[k];\n\t})\n}\n\nfunction applyProjectionGet(obj,$set,nobj) {\n\t_.each($set, function (v,k) {\n\t\tvar path = k.split(\".\")\n\t\tvar t = null,n=null;\n\t\tif (path.length==1) {\n\t\t\tt = obj;\n\t\t\tn = nobj;\n\t\t}\n\t\telse {\n\t\t\tvar l = obj, nl = nobj;\n\t\t\tfor (var i=0; i<path.length-1; i++) {\n\t\t\t\tvar p = path[i];\n\t\t\t\tif (l[p]==null) break; l = l[p];\n\t\t\t\tif (nl[p]==null) nl[p]={}; nl = nl[p];\n\t\t\t}\n\t\t\tif (i==path.length-1) {\n\t\t\t\tt = l;\n\t\t\t\tn = nl;\n\t\t\t}\n\t\t\tk = path[i];\n\t\t}\n\t\tif (!_.isUndefined(t[k])) {\n\t\t\tn[k] = t[k];\n\t\t}\n\t})\n\treturn nobj;\n}\n\n\n\ntcursor.prototype.isClosed  = function () {\n\tif (!this._items)\n\t\treturn false;\n\treturn this._i==-1 || this._i>=this._items.length;\n}\n\ntcursor.prototype.skip = function (v, cb) {\n\tvar self = this;\n\tif (!_.isFinite(v)) {\n\t\tself._err = new Error(\"skip requires an integer\");\n\t\tif (!cb) throw self._err;\n\t}\n\tif (self._i!=0) {\n\t\tself._err = new Error('Cursor is closed');\n\t\tif (!cb) throw self._err;\n\t}\n\tif (!self._err)\n\t\tthis._skip = v;\n\tif (cb)\n\t\tprocess.nextTick(function () {cb(self._err,self)})\n\treturn this;\n}\n\nfunction parseSortList(l, d) {\n\tvar message = \"Illegal sort clause, \" +\n\t\t\"must be of the form [['field1', '(ascending|descending)'], \" +\n\t\t\"['field2', '(ascending|descending)']]\";\n\t// null or empty string\n\tif (!l) return null;\n\t// sanity check\n\tif (!_.isObject(l) && !_.isString(l)) throw new Error(message);\n\t// 'a' => [ [ 'a', 1 ] ]\n\tif (!d) d = 1;\n\t// 'a', 1 => [ [ 'a', 1 ] ]\n\tif (_.isString(l)) l = [ [ l, d ] ];\n\t// { a: 1, b: -1 } => [ [ 'a', 1 ], [ 'b', -1 ] ]\n\telse if (!_.isArray(l)) l = _.map(l, function (v, k) { return [ k, v ]; });\n\t// [ 'a', 1 ], [ 'a', 'asc' ] => [ [ 'a', 1 ] ]\n\telse if (_.isString(l[0]) && (l[1] == 1 || l[1] == -1 ||\n\t\t\t\tl[1] == 'asc' || l[1] == 'ascending' ||\n\t\t\t\tl[1] == 'desc' || l[1] == 'descending')) l = [ l ];\n\t// [ 'a', 'b' ] => [ [ 'a', 1 ], [ 'b', 1 ] ]\n\telse if (_.every(l, _.isString)) l = _.map(l, function (v) { return [ v, d ]; });\n\t// empty array or object\n\tif (_.isEmpty(l)) return null;\n\t// 'asc', 'ascending' => 1; 'desc', 'descending' => -1\n\treturn _.map(l, function (v) {\n\t\tvar d = v[1];\n\t\tif (d == 'asc' || d == 'ascending') d = 1;\n\t\telse if (d == 'desc' || d == 'descending') d = -1;\n\t\tif (d != 1 && d != -1) throw new Error(message);\n\t\treturn [ v[0], d ];\n\t});\n}\n\ntcursor.prototype.sort = function (v, d, cb) {\n\tvar self = this;\n\tif (_.isFunction(d)) {\n\t\tcb = d;\n\t\td = null;\n\t}\n\tif (self._i!=0)\n\t\tthis._err = new Error('Cursor is closed');\n\tif (!this._err) {\n\t\tthis._err = _.attempt(function () {\n\t\t\tself.sortValue = v; // just to pass contrib test\n\t\t\tself._sort = parseSortList(v, d);\n\t\t});\n\t}\n\tif (cb)\n\t\tprocess.nextTick(function () {cb(self._err, self)})\n\treturn this;\n}\n\ntcursor.prototype.limit = function (v, cb) {\n\tvar self = this;\n\tif (!_.isFinite(v)) {\n\t\tself._err = new Error(\"limit requires an integer\");\n\t\tif (!cb) throw self._err;\n\t}\n\tif (self._i!=0) {\n\t\tself._err = new Error('Cursor is closed');\n\t\tif (!cb) throw self._err;\n\t}\n\tif (!self._err) {\n\t\tthis._limit = v==0?null:Math.abs(v);\n\t}\n\tif (cb)\n\t\tprocess.nextTick(function () {cb(self._err,self)})\n\treturn this;\n}\n\ntcursor.prototype.nextObject = function (cb) {\n\tvar self = this;\n\tif (self._err) {\n\t\tif (cb) process.nextTick(function () {cb(self._err)})\n\t\treturn;\n\t}\n\tself._ensure(safe.sure(cb, function () {\n\t\tif (self._i>=self._items.length)\n\t\t\treturn cb(null, null);\n\t\tself._get(self._items[self._i], cb)\n\t\tself._i++;\n\t}))\n}\n\ntcursor.prototype.count = function (applySkipLimit, cb) {\n\tvar self = this;\n\tif (!cb) {\n\t\tcb = applySkipLimit;\n\t\tapplySkipLimit = false;\n\t}\n\tif (self._err) {\n\t\tif (cb) process.nextTick(function () {cb(self._err)})\n\t\treturn;\n\t}\n\tif ((!self._skip && self._limit === null) || applySkipLimit) {\n\t\tself._ensure(safe.sure(cb, function () {\n\t\t\tcb(null, self._items.length);\n\t\t}));\n\t\treturn;\n\t}\n\tif (self._count !== null) {\n\t\tprocess.nextTick(function () {\n\t\t\tcb(null, self._count);\n\t\t});\n\t\treturn;\n\t}\n\tself._c._find(self._query, {}, 0, null, null, self._hint, self._arFields, safe.sure(cb, function (data) {\n\t\tself._count = data.length;\n\t\tcb(null, self._count);\n\t}));\n}\n\ntcursor.prototype.setReadPreference = function (the, cb) {\n\tvar self = this;\n\tif (self._err) {\n\t\tif (cb) process.nextTick(function () {cb(self._err)})\n\t\treturn;\n\t}\n\treturn this;\n}\n\ntcursor.prototype.batchSize = function (v, cb) {\n\tvar self = this;\n\tif (!_.isFinite(v)) {\n\t\tself._err = new Error(\"batchSize requires an integer\");\n\t\tif (!cb) throw self._err;\n\t}\n\tif (self._i!=0) {\n\t\tself._err = new Error('Cursor is closed');\n\t\tif (!cb) throw self._err;\n\t}\n\tif (cb) process.nextTick(function () {cb(self._err,self)})\n\treturn this;\n}\n\ntcursor.prototype.close = function (cb) {\n\tvar self = this;\n\tthis._items = [];\n\tthis._i=-1;\n\tthis._err = null;\n\tif (cb)\n\t\tprocess.nextTick(function () {cb(self._err,self)})\n\treturn this;\n}\n\ntcursor.prototype.rewind = function () {\n\tthis._i=0;\n\treturn this;\n}\n\ntcursor.prototype.toArray = function (cb) {\n\tif (!_.isFunction(cb))\n\t\tthrow new Error('Callback is required');\n\tvar self = this;\n\n\tif (self.isClosed())\n\t\tself._err = new Error(\"Cursor is closed\");\n\n\tif (self._err) {\n\t\tif (cb) process.nextTick(function () {cb(self._err)})\n\t\treturn;\n\t}\n\n\tself._ensure(safe.sure(cb, function () {\n\t\tsafe.mapSeries(self._i!=0?self._items.slice(self._i,self._items.length):self._items, function (pos,cb) {\n\t\t\tself._get(pos, safe.sure(cb, function (obj) {\n\t\t\t\tcb(null, obj);\n\t\t\t}));\n\t\t}, safe.sure(cb, function (res) {\n\t\t\tself._i=self._items.length;\n\t\t\tcb(null, res);\n\t\t}))\n\t}))\n}\n\ntcursor.prototype.each = function (cb) {\n\tif (!_.isFunction(cb))\n\t\tthrow new Error('Callback is required');\n\n\tvar self = this;\n\n\tif (self.isClosed())\n\t\tself._err = new Error(\"Cursor is closed\");\n\n\tif (self._err) {\n\t\tif (cb) process.nextTick(function () {cb(self._err)})\n\t\treturn;\n\t}\n\tself._ensure(safe.sure(cb, function () {\n\t\tsafe.forEachSeries(self._i!=0?self._items.slice(self._i,self._items.length):self._items, function (pos,cb1) {\n\t\t\tself._get(pos, safe.sure(cb, function (obj) {\n\t\t\t\tcb(null,obj)\n\t\t\t\tcb1();\n\t\t\t}))\n\t\t}, safe.sure(cb, function () {\n\t\t\tself._i=self._items.length;\n\t\t\tcb(null, null);\n\t\t}))\n\t}))\n}\n\ntcursor.prototype.stream = function (options) {\n\treturn new CursorStream(this, options);\n};\n\ntcursor.prototype._ensure = function (cb) {\n\tvar self = this;\n\tif (self._items!=null)\n\t\treturn process.nextTick(cb);\n\tself._c._find(self._query, {}, self._skip, self._limit, self._sort, self._hint, self._arFields, safe.sure_result(cb, function (data) {\n\t\tself._items = data;\n\t\tself._i=0;\n\t}))\n}\n\ntcursor.prototype._projectFields = function (obj) {\n\tvar self = this;\n\tif (self._fieldsType!=null) {\n\t\tif (self._fieldsType==0) {\n\t\t\tapplyProjectionDel(obj,self._fields)\n\t\t}\n\t\telse\n\t\t\tobj = applyProjectionGet(obj, self._fields,self._fieldsExcludeId?{}:{_id:obj._id})\n\t}\n\treturn obj;\n}\n\ntcursor.prototype._get = function (pos,cb) {\n\tvar self = this;\n\tself._c._get(pos, false, safe.sure(cb, function (obj) {\n\t\tcb(null,self._projectFields(obj))\n\t}))\n}\n\nmodule.exports = tcursor;\n","/home/travis/build/npmtest/node-npmtest-tingodb/node_modules/tingodb/lib/tstream.js":"var timers = require('timers');\nvar _ = require('lodash');\n\n// Set processor, setImmediate if 0.10 otherwise nextTick\nvar processor = timers.setImmediate ? timers.setImmediate : process.nextTick;\n\n/**\n * Module dependecies.\n */\nvar Stream = require('stream').Stream;\n\n/**\n * CursorStream\n *\n * Returns a stream interface for the **cursor**.\n *\n * Options\n *  - **transform** {Function} function of type function(object) { return transformed }, allows for transformation of data before emitting.\n *\n * Events\n *  - **data** {function(item) {}} the data event triggers when a document is ready.\n *  - **error** {function(err) {}} the error event triggers if an error happens.\n *  - **close** {function() {}} the end event triggers when there is no more documents available.\n *\n * @class Represents a CursorStream.\n * @param {Cursor} cursor a cursor object that the stream wraps.\n * @return {Stream}\n */\nfunction CursorStream(cursor, options) {\n  if(!(this instanceof CursorStream)) return new CursorStream(cursor);\n  options = options ? options : {};\n\n  Stream.call(this);\n\n  this.readable = true;\n  this.paused = false;\n  this._cursor = cursor;\n  this._destroyed = null;\n  this.options = options;\n\n  // give time to hook up events\n  var self = this;\n  process.nextTick(function() {\n    self._init();\n  });\n}\n\n/**\n * Inherit from Stream\n * @ignore\n * @api private\n */\nCursorStream.prototype.__proto__ = Stream.prototype;\n\n/**\n * Flag stating whether or not this stream is readable.\n */\nCursorStream.prototype.readable;\n\n/**\n * Flag stating whether or not this stream is paused.\n */\nCursorStream.prototype.paused;\n\n/**\n * Initialize the cursor.\n * @ignore\n * @api private\n */\nCursorStream.prototype._init = function () {\n  if (this._destroyed) return;\n  this._next();\n}\n\n/**\n * Pull the next document from the cursor.\n * @ignore\n * @api private\n */\nCursorStream.prototype._next = function () {\n  if(this.paused || this._destroyed) return;\n\n  var self = this;\n  // Get the next object\n  processor(function() {\n    if(self.paused || self._destroyed) return;\n\n    self._cursor.nextObject(function (err, doc) {\n      self._onNextObject(err, doc);\n    });\n  });\n}\n\n/**\n * Handle each document as its returned from the cursor.\n * @ignore\n * @api private\n */\nCursorStream.prototype._onNextObject = function (err, doc) {\n  if(err) return this.destroy(err);\n\n  // when doc is null we hit the end of the cursor\n  //if(!doc && (this._cursor.state == 1 || this._cursor.state == 2)) {\n  if(!doc) {\n    this.emit('end')\n    return this.destroy();\n  } else if(doc) {\n    var data = _.isFunction(this.options.transform) ? this.options.transform(doc) : doc;\n    this.emit('data', data);\n    this._next();\n  }\n}\n\n/**\n * Pauses the stream.\n *\n * @api public\n */\nCursorStream.prototype.pause = function () {\n  this.paused = true;\n}\n\n/**\n * Resumes the stream.\n *\n * @api public\n */\nCursorStream.prototype.resume = function () {\n  var self = this;\n\n  // Don't do anything if we are not paused\n  if(!this.paused) return;\n  //if(!this._cursor.state == 3) return;\n\n  process.nextTick(function() {\n    self.paused = false;\n    // Only trigger more fetching if the cursor is open\n    self._next();\n  })\n}\n\n/**\n * Destroys the stream, closing the underlying\n * cursor. No more events will be emitted.\n *\n * @api public\n */\nCursorStream.prototype.destroy = function (err) {\n  if (this._destroyed) return;\n  this._destroyed = true;\n  this.readable = false;\n\n  this._cursor.close();\n\n  if(err) {\n    this.emit('error', err);\n  }\n\n  this.emit('close');\n}\n\n// TODO - maybe implement the raw option to pass binary?\n//CursorStream.prototype.setEncoding = function () {\n//}\n\nmodule.exports = exports = CursorStream;\n","/home/travis/build/npmtest/node-npmtest-tingodb/node_modules/tingodb/lib/wqueue.js":"function wqueue (limit,first) {\n\tthis.limit = limit || 100;\n\tthis._rc = 0;\n\tthis._q = [];\n\tthis._blocked = false;\n\tthis._stoped = false;\n\tthis._tc = -1;\n\tthis.first = first || function (cb) {cb()};\n}\n\nwqueue.prototype.add = function(task,block,cb) {\n\tthis._q.push({task:task,block:block, cb:cb});\n\tthis._ping();\n}\n\nwqueue.prototype._exec = function (task,block,cb) {\n\tvar self = this;\n\tself._blocked = block;\n\tself._tc++;\n\tif (self._tc==0) {\n\t\tself._blocked = true;\n\t\tself.first(function (err) {\n\t\t\tif (err) {\n\t\t\t\t// restore to initial state on error\n\t\t\t\tself._blocked = false;\n\t\t\t\tself._tc--;\n\t\t\t\treturn cb(err);\n\t\t\t}\n\t\t\tself._exec(task,block,cb)\n\t\t})\n\t} else {\n\t\tself._rc++;\n\t\ttask(function () {\n\t\t\tcb.apply(this,arguments)\n\t\t\tself._rc--;\n\t\t\tif (self._rc==0)\n\t\t\t\tself._blocked = false;\n\t\t\tself._ping();\n\t\t})\n\t}\n}\n\nwqueue.prototype._ping = function () {\n\tvar self = this;\n\tprocess.nextTick(function () {\n\t\twhile (self._q.length>0 && self._rc<self.limit && !self._blocked && (!self._q[0].block || self._rc==0)  ) {\n\t\t\tvar t = self._q.splice(0,1)[0];\n\t\t\tif (self._stoped)\n\t\t\t\tt.cb(new Error(\"Database is closed\"));\n\t\t\telse {\n\t\t\t\tself._exec(t.task, t.block, t.cb)\n\t\t\t}\n\t\t}\n\t})\n}\n\nmodule.exports = wqueue;\n","/home/travis/build/npmtest/node-npmtest-tingodb/node_modules/tingodb/lib/tindex.js":"var _ = require('lodash');\nvar BPlusTree = require('./bplustree');\n\nfunction tindex (key,tcoll,options,name) {\n\tthis.options = options || {};\n\tthis.name = name || key+'_';\n\tthis._unique = this.options.unique || false;\n\tthis._c = tcoll;\n\tthis._nuls = Object.create ? Object.create(null) : {};\n\tthis._array = this.options._tiarr || false;\n\tthis.key = key[0][0];\n\tthis.order = key[0][1];\n\tif (key.length > 1) this._sub = key.slice(1);\n\tthis._bp = BPlusTree.create({ sort: this.order, order: 100 });\n\tvar getter = new tcoll._tdb.Finder.field(this.key);\n\tthis._get = new Function(\"obj\", \"return \" + (this._array ? getter.native3() : getter.native()));\n}\ntindex.prototype.clear = function () {\n\tif (this.count())\n\t\tthis._bp = BPlusTree.create({ sort: this.order, order: 100 });\n};\n\ntindex.prototype.set = function (k_,v, check) {\n\tvar self = this;\n\tvar k = this._get(k_);\n\n\tif (check) {\n\t\tif (!this._sub && this._unique && this._bp.get(k) !== null)\n\t\t\tthrow new Error(\"duplicate key error index\");\n\t} else {\n\t\tif (_.isArray(k)) {\n\t\t\t_.each(k, function (k1) {\n\t\t\t\tself._set(k1, v, k_);\n\t\t\t});\n\t\t}\n\t\telse\n\t\t\treturn this._set(k, v, k_);\n\t}\n};\n\ntindex.prototype._set = function (k, v, o) {\n\tif (this._sub) {\n\t\tvar s = (_.isNull(k) || _.isUndefined(k)) ? this._nuls[v] : this._bp.get(k);\n\t\tif (!s) {\n\t\t\ts = new tindex(this._sub, this._c, this.options, this.name + '_' + k);\n\t\t\tif (_.isNull(k) || _.isUndefined(k)) this._nuls[v] = s;\n\t\t\t\telse this._bp.set(k, s);\n\t\t}\n\t\ts.set(o, v);\n\t\treturn;\n\t}\n\tif (_.isNull(k) || _.isUndefined(k)) {\n\t\tthis._nuls[v]=v;\n\t\treturn;\n\t}\n\tif (this._unique)\n\t\treturn this._bp.set(k,v);\n\telse {\n\t\tvar l = this._bp.get(k);\n\t\tvar n = l || [];\n\t\tn.push(v);\n\t\tif (!l) this._bp.set(k,n);\n\t}\n};\n\ntindex.prototype.del = function (k_,v) {\n\tvar self = this;\n\tvar k = this._get(k_);\n\tif (_.isArray(k)) {\n\t\t_.each(k, function (k1) {\n\t\t\tself._del(k1, v, k_);\n\t\t});\n\t}\n\telse\n\t\treturn this._del(k, v, k_);\n};\n\ntindex.prototype._del = function (k, v, o) {\n\tif (this._sub) {\n\t\tvar s = (_.isNull(k) || _.isUndefined(k)) ? this._nuls[v] : this._bp.get(k);\n\t\tif (s) s.del(o, v);\n\t\treturn;\n\t}\n\tdelete this._nuls[v];\n\tif (this._unique) {\n\t\tthis._bp.del(k);\n\t}\n\telse {\n\t\tvar l = this._bp.get(k);\n\t\tif (l) {\n\t\t\tvar i = l.indexOf(v);\n\t\t\tif (i != -1)\n\t\t\t\tl.splice(i, 1);\n\t\t\tif (l.length===0)\n\t\t\t\tthis._bp.del(k);\n\t\t}\n\t}\n};\n\ntindex.prototype.match = function (k) {\n\tvar m = this._bp.get(k);\n\tif (!m) return [];\n\treturn this._unique || this._sub ? [ m ] : m;\n};\n\ntindex.prototype.range = function (s, e, si, ei) {\n\tvar r = this._bp.rangeSync(s,e,si,ei);\n\treturn this._unique || this._sub ? r : _.flatten(r);\n};\n\ntindex.prototype.all = function (order, shallow) {\n\tvar a = this._bp.all();\n\tvar n = _.values(this._nuls);\n\tvar r = this.order > 0 ? _.union(n, a) : _.union(a, n);\n\tif (order && order.length > 0) {\n\t\tif (order[0] != this.order) r = r.reverse();\n\t\torder = order.slice(1);\n\t}\n\tif (this._sub) return shallow ? r : _(r).map(function (i) { return i.all(order); }).flattenDeep().value();\n\treturn this._unique?r:_.flatten(r);\n};\n\ntindex.prototype.nuls = function () {\n\treturn _.values(this._nuls);\n};\n\ntindex.prototype.values = function () {\n\tvar r = this._bp.all();\n\treturn this._unique || this._sub ? r : _.flatten(r);\n};\n\ntindex.prototype.count = function () {\n\tvar c = 0;\n\tthis._bp.each(function (k,v) {\n\t\tc += this._sub ? v.count() : v.length;\n\t});\n\treturn c;\n};\n\ntindex.prototype.fields = function () {\n\tvar result = [ [ this.key, this.order ] ];\n\tif (this._sub) result = result.concat(this._sub);\n\treturn result;\n};\n\ntindex.prototype.depth = function () {\n\treturn this._sub ? this._sub.length + 1 : 1;\n};\n\ntindex.prototype.inspect = function (depth) {\n\treturn '[Index ' + this.name + ']';\n};\n\nmodule.exports = tindex;\n\n/* IDEAS\n *\n * - Keep some stats about index to allow of making decisions about which index to use in query\n *\n */\n","/home/travis/build/npmtest/node-npmtest-tingodb/node_modules/tingodb/lib/bplustree/index.js":"var LeafNode     = require('./leaf_node'),\n    InternalNode = require('./internal_node');\n\nvar default_options = {\n  order: 100, // Min 1\n  sort: 1 // 1, -1 or array\n};\n\nvar BPlusTree = module.exports = function(options) {\n  this.options = options || default_options;\n  if (!this.options.order) {\n    this.options.order = default_options.order;\n  }\n  if (!this.options.sort) {\n    this.options.sort = default_options.sort;\n  }\n\n  var self = this;\n  if (Array.isArray(this.options.sort)) this._compare = function (a1, a2) {\n\t  if (a2.length > a1.length) return -self._compare(a2, a1);\n\t  for (var i = 0; i < a1.length; i++) {\n\t\t  if (i >= a2.length) return self.options.sort[i];\n\t\t  var v1 = a1[i];\n\t\t  var v2 = a2[i];\n\t\t  if (v1 < v2) return -self.options.sort[i];\n\t\t  else if (v1 > v2) return self.options.sort[i];\n\t  }\n\t  return 0;\n  };\n  else this._compare = function (k1, k2) {\n\t  if (k1 < k2) return -self.options.sort;\n\t  else if (k1 > k2) return self.options.sort;\n\t  else if (k1 == k2) return 0;\n\t  // else FIXME: probably different data types\n  };\n\n  this.root = new LeafNode(options.order, this._compare);\n};\n\n\nBPlusTree.prototype.set = function(key, value) {\n  var node = this._search(key);\n  var ret = node.insert(key, value);\n  if (ret) {\n    this.root = ret;\n  }\n};\n\nBPlusTree.prototype.get = function(key) {\n  var node = this._search(key);\n  for(var i=0; i<node.data.length; i++){\n    if(this._compare(node.data[i].key, key) === 0) return node.data[i].value;\n  }\n  return null;\n};\n\nBPlusTree.prototype.del = function(key) {\n  var node = this._search(key);\n  for(var i=0; i<node.data.length; i++){\n    if(this._compare(node.data[i].key, key) === 0) {\n\t\tnode.data.splice(i,1)\n\t\t// TODO, NOTE SURE IF THIS IS ENOUGH\n\t\tbreak;\n\t}\n  }\n  return null;\n};\n\nBPlusTree.prototype.getNode = function(key) {\n  return this._search(key);\n};\n\nBPlusTree.prototype._search = function(key) {\n  var current = this.root;\n  var found = false;\n\n  while(current.isInternalNode){\n    found = false;\n    var len = current.data.length;\n    for(var i=1; i<len; i+=2){\n      if(this._compare(key, current.data[i]) <= 0) {\n        current = current.data[i-1];\n        found = true;\n        break;\n      }\n    }\n\n    // Follow infinity pointer\n    if(!found) current = current.data[len - 1];\n  }\n\n  return current;\n};\n\n// walk the tree in order\nBPlusTree.prototype.each = function(callback, node) {\n  if (!node) {\n    node = this.root;\n  }\n  var current = node;\n  if(current.isLeafNode){\n    for(var i = 0; i < current.data.length; i++) {\n      var node = current.data[i];\n      if (node.value) {\n        callback(node.key, node.value);\n      }\n    }\n  } else {\n    for(var i=0; i<node.data.length; i+=2) {\n      this.each(callback, node.data[i]);\n    }\n  }\n};\n\n// walk the tree in order\nBPlusTree.prototype.all = function(node,res) {\n  if (!res)\n\tres = [];\n  if (!node) {\n    node = this.root;\n  }\n  var current = node;\n  if(current.isLeafNode){\n    for(var i = 0; i < current.data.length; i++) {\n      var node = current.data[i];\n      res.push(node.value)\n    }\n  } else {\n    for(var i=0; i<node.data.length; i+=2) {\n      this.all(node.data[i],res);\n    }\n  }\n  return res;\n};\n\nBPlusTree.prototype.each_reverse = function(callback, node) {\n  if (!node) {\n    node = this.root;\n  }\n  var current = node;\n  if(current.isLeafNode){\n    for(var i = current.data.length - 1; i >= 0 ; i--) {\n      var node = current.data[i];\n      if (node.value) {\n        callback(node.key, node.value);\n      }\n    }\n  } else {\n    for(var i=node.data.length - 1; i >= 0; i-=2) {\n      this.each(callback, node.data[i]);\n    }\n  }\n};\n\n\n// Get a range\nBPlusTree.prototype.range = function(start, end, callback) {\n  var node = this._search(start);\n  if (!node) {\n    node = this.root;\n    while (!node.isLeafNode) {\n      node = node[0]; // smallest node\n    }\n  }\n  var ended = false;\n\n  while (!ended) {\n    for(var i = 0; i < node.data.length; i ++) {\n      var data = node.data[i];\n      var key = data.key;\n      if (end && this._compare(key, end) > 0) {\n        ended = true;\n        break;\n      } else {\n        if ((start === undefined || this._compare(start, key) <= 0) && (end === undefined || this._compare(end, key) >= 0) && data.value) {\n          callback(key, data.value);\n        }\n      }\n    }\n    node = node.nextNode;\n    if (!node) {\n      ended = true\n    }\n  }\n};\n\nBPlusTree.prototype.rangeSync = function(start, end, exclusive_start, exclusive_end) {\n  var values = [];\n  var node = this._search(start);\n  if (!node) {\n    node = this.root;\n    while (!node.isLeafNode) {\n      node = node[0]; // smallest node\n    }\n  }\n  var ended = false;\n\n  var self = this;\n  function keyCheck(key) {\n        return (start === undefined\n            || start === null\n            || !exclusive_start && self._compare(start, key) <= 0\n            || exclusive_start && self._compare(start, key) < 0\n          ) && (\n               end === undefined\n            || end === null\n            || !exclusive_end && self._compare(end, key) >= 0\n            || exclusive_end && self._compare(end, key) > 0\n          )\n\t}\n\n  while (!ended) {\n\tif (values.length && node.data.length>0 && keyCheck(node.data[0].key,node.data[0].value) &&\n\t\tkeyCheck(node.data[node.data.length-1].key,node.data[node.data.length-1].value))\n\t{\n\t\t// entire node is in range\n\t\tfor(var i = 0; i < node.data.length; i ++) {\n\t\t\tvalues.push(node.data[i].value);\n\t\t}\n\t} else {\n\t\tfor(var i = 0; i < node.data.length; i ++) {\n\t\t  var data = node.data[i];\n\t\t  var key = data.key;\n\t\t  if (end && this._compare(key, end) > 0) {\n\t\t\tended = true;\n\t\t\tbreak;\n\t\t  } else {\n\t\t\t  if (keyCheck(key,data.value))\n\t\t\t\tvalues.push(data.value);\n\t\t  }\n\t  }\n    }\n    node = node.nextNode;\n    if (!node) {\n      ended = true\n    }\n  }\n  return values;\n};\n\n// B+ tree dump routines\nBPlusTree.prototype.walk = function(node, level, arr) {\n  var current = node;\n  if(!arr[level]) arr[level] = [];\n\n  if(current.isLeafNode){\n    for(var i=0; i<current.data.length; i++){\n      arr[level].push(\"<\"+current.data[i].key+\">\");\n    }\n    arr[level].push(\" -> \");\n  }else{\n\n    for(var i=1; i<node.data.length; i+=2){\n      arr[level].push(\"<\"+node.data[i]+\">\");\n    }\n    arr[level].push(\" -> \");\n    for(var i=0; i<node.data.length; i+=2) {\n      this.walk(node.data[i], level+1, arr);\n    }\n\n  }\n  return arr;\n};\n\nBPlusTree.prototype.dump = function() {\n  var arr = [];\n  this.walk(this.root, 0, arr);\n  for(var i=0; i<arr.length; i++){\n    var s = \"\";\n    for(var j=0; j<arr[i].length; j++){\n      s += arr[i][j];\n    }\n  }\n  return s;\n};\n\nmodule.exports.create = function(options) {\n  return new BPlusTree(options);\n};\n","/home/travis/build/npmtest/node-npmtest-tingodb/node_modules/tingodb/lib/bplustree/leaf_node.js":"var InternalNode = require('./internal_node');\n\nvar LeafNode = module.exports = function(order, compare) {\n  this.order = order;\n  this.compare = compare;\n  this.isLeafNode = true;\n  this.isInternalNode = false;\n\n  this.parentNode = null;\n  this.nextNode = null;\n  this.prevNode = null;\n\n  this.data = [];\n\n};\n\nLeafNode.prototype.split = function() {\n  var tmp = new LeafNode(this.order, this.compare);\n  var m = Math.ceil(this.data.length / 2);\n  var k = this.data[m-1].key;\n\n  // Copy & shift data\n  for(var i=0; i<m; i++){\n    tmp.data[i] = this.data.shift();\n  }\n  tmp.parentNode = this.parentNode;\n  tmp.nextNode = this;\n  tmp.prevNode = this.prevNode;\n  if(tmp.prevNode) tmp.prevNode.nextNode = tmp;\n  this.prevNode = tmp;\n\n  if(!this.parentNode){\n    var p = new InternalNode(this.order, this.compare);\n    this.parentNode = tmp.parentNode = p;\n  }\n\n  return this.parentNode.insert(k, tmp, this);\n};\n\nLeafNode.prototype.insert = function(key, value) {\n  var pos = 0;\n  for(; pos<this.data.length; pos++){\n    if(this.compare(this.data[pos].key, key) === 0) {\n      this.data[pos].value = value;\n      return null;\n    }\n    if(this.compare(this.data[pos].key, key) > 0) break;\n  }\n\n  if (this.data[pos]) {\n    this.data.splice(pos, 0, {\"key\": key, \"value\": value});\n  } else {\n    this.data.push({\"key\": key, \"value\": value});\n  }\n\n  // Split\n  if(this.data.length > this.order) {\n    return this.split();\n  }\n\n  return null;\n};\n","/home/travis/build/npmtest/node-npmtest-tingodb/node_modules/tingodb/lib/bplustree/internal_node.js":"var InternalNode = module.exports = function(order, compare) {\n  this.order = order;\n  this.compare = compare;\n  this.isLeafNode = false;\n  this.isInternalNode = true;\n\n  this.parentNode = null;\n\n  this.data = [];\n};\n\nInternalNode.prototype.split = function() {\n  var time = Date.now();\n  var m = null;\n  if(this.order % 2){\n    var m = (this.data.length-1)/2 - 1;\n  }else{\n    var m = (this.data.length-1)/2;\n  }\n\n  var tmp = new InternalNode(this.order, this.compare);\n  tmp.parentNode = this.parentNode;\n  for(var i=0; i<m; i++){\n    tmp.data[i] = this.data.shift();\n  }\n  for(var i=0; i<tmp.data.length; i+=2){\n    tmp.data[i].parentNode = tmp;\n  }\n  var key = this.data.shift();\n\n  if(!this.parentNode){\n    this.parentNode = tmp.parentNode = new InternalNode(this.order, this.compare);\n  }\n\n  return this.parentNode.insert(key, tmp, this);\n};\n\nInternalNode.prototype.insert = function(key, node1, node2) {\n  if(this.data.length){\n    var pos = 1;\n    for(; pos < this.data.length; pos+=2){\n      if(this.compare(this.data[pos], key) > 0) break;\n    }\n\n    if(pos<this.data.length) {\n      pos--;\n      this.data.splice(pos, 0, key);\n      this.data.splice(pos, 0, node1);\n    }else{\n      this.data[pos-1] = node1;\n      this.data.push(key);\n      this.data.push(node2);\n    }\n\n    if(this.data.length > (this.order*2+1)){\n      return this.split();\n    }\n    return null;\n  }else{\n    this.data[0] = node1;\n    this.data[1] = key;\n    this.data[2] = node2;\n    return this;\n  }\n};\n","/home/travis/build/npmtest/node-npmtest-tingodb/node_modules/tingodb/lib/utils.js":"var _ = require('lodash')\n\nmodule.exports.intersectIndexes = function (indexes,base) {\n\t// do intersection of indexes using hashes\n\tvar ops = [], i = 0;\n\t// convert to hashes\n\tfor (i=0; i<indexes.length; i++) {\n\t\tvar ids = {};\n\t\t_.each(indexes[i], function (id) {\n\t\t\tids[id]=id;\n\t\t})\n\t\tops.push(ids);\n\t}\n\t// find minimal one\n\tif (_.isUndefined(base)) {\n\t\tbase = 0;\n\t\tfor (i=0; i<ops.length; i++) {\n\t\t\tif (ops[i].length<ops[base].length)\n\t\t\t\tbase = i;\n\t\t}\n\t}\n\t// iterate over it\n\tvar m = [];\n\t_.each(indexes[base], function (id) {\n\t\tvar match = true;\n\t\tfor (var i=0; i<ops.length; i++) {\n\t\t\tif (i==base) continue;\n\t\t\tif (!ops[i][id]) {\n\t\t\t\tmatch = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (match)\n\t\t\tm.push(id);\n\t})\n\treturn m;\n}\n","/home/travis/build/npmtest/node-npmtest-tingodb/node_modules/tingodb/lib/updater.js":"var _ = require('lodash');\n\nfunction ensurePath(obj,k,cb) {\n\tvar path = k.split(\".\")\n\tvar t = null;\n\tif (path.length==1)\n\t\tt = obj\n\telse {\n\t\tvar l = obj;\n\t\tfor (var i=0; i<path.length-1; i++) {\n\t\t\tvar p = path[i];\n\t\t\tif (!l[p])\n\t\t\t\tl[p] = {};\n\t\t\tl = l[p];\n\t\t}\n\t\tt = l;\n\t\tk = path[i];\n\t}\n\tcb(t,k)\n}\n\nfunction applySet(obj,$set) {\n\t_.each($set, function (v,k) {\n\t\t_.set(obj,k,v);\n\t});\n}\n\nfunction applyUnset(obj,$unset) {\n\t_.each($unset, function (v,k) {\n\t\t_.unset(obj,k);\n\t});\n}\n\nfunction applyInc(obj, $inc) {\n\t_.each($inc, function (v, k) {\n\t\tensurePath(obj,k, function (t,k) {\n\t\t\tif (!t[k]) t[k] = 0;\n\t\t\tif (!_.isFinite(t[k]))\n\t\t\t\tthrow new Error(\"Cannot apply $inc modifier to non-number\");\n\t\t\tt[k] += v;\n\t\t})\n\t});\n}\n\nfunction applyPush(obj,$push) {\n\t_.each($push, function (v,k) {\n\t\tensurePath(obj,k, function (t,k) {\n\t\t\tif (!t[k]) {\n\t\t\t\tt[k] = v.$each?v.$each:[v];\n\t\t\t} else {\n\t\t\t\tif (!_.isArray(t[k]))\n\t\t\t\t\tthrow new Error(\"Cannot apply $push/$pushAll modifier to non-array\")\n\n\t\t\t\tif (v.$each) {\n\t\t\t\t\tt[k] = t[k].concat(v.$each);\n\t\t\t\t} else\n\t\t\t\t\tt[k].push(v);\n\t\t\t}\n\t\t})\n\t})\n}\n\nfunction applyPop(obj,$op) {\n\t_.each($op, function (v,k) {\n\t\tvar path = k.split(\".\"); var t = obj;\n\t\tfor (var i=0; i<path.length-1 && t[path[i]]; t=t[path[i++]]); k = path[i];\n\t\tif (t==null || t[k]==null) return;\n\t\tif (_.isArray(t[k])) {\n\t\t\tif (v>=0)\n\t\t\t\tt[k]=t[k].slice(0,-1)\n\t\t\telse if (v==-1)\n\t\t\t\tt[k]=t[k].slice(1)\n\t\t} else throw new Error(\"Cannot apply $pop modifier to non-array\");\n\t})\n}\n\nfunction applyPull(obj,$op,tdb) {\n\t_.each($op, function (v,k) {\n\t\tvar path = k.split(\".\"); var t = obj;\n\t\tfor (var i=0; i<path.length-1 && t[path[i]]; t=t[path[i++]]); k = path[i];\n\t\tif (t==null || t[k]==null) return;\n\t\tif (_.isArray(t[k])) {\n\t\t\tvar qt = tdb.Finder.matcher({v:v});\n\t\t\tvar matcher = new Function(\"obj\", \"return \" + (qt.native()) );\n\t\t\tt[k] = _.reject(t[k], function (obj) { return matcher({v:obj}); });\n\t\t} else throw new Error(\"Cannot apply $pull/$pullAll modifier to non-array\");\n\t})\n}\n\nfunction applyPullAll(obj,$op) {\n\t_.each($op, function (v,k) {\n\t\tvar path = k.split(\".\"); var t = obj;\n\t\tfor (var i=0; i<path.length-1 && t[path[i]]; t=t[path[i++]]); k = path[i];\n\t\tif (t==null || t[k]==null) return;\n\t\tif (_.isArray(t[k])) {\n\t\t\tt[k] = _.difference(t[k], v);\n\t\t} else throw new Error(\"Cannot apply $pull/$pullAll modifier to non-array\");\n\t})\n}\n\nfunction applyRename(obj,$op) {\n\t_.each($op, function (v,k) {\n\t\tvar path = k.split(\".\"); var t = obj;\n\t\tfor (var i=0; i<path.length-1 && t[path[i]]; t=t[path[i++]]); k = path[i];\n\t\tif (t==null || t[k]==null) return;\n\t\tensurePath(obj,v, function (t1,k1) {\n\t\t\tt1[k1] = t[k];\n\t\t\tdelete t[k];\n\t\t})\n\t})\n}\n\nfunction applyAddToSet(obj,$op) {\n\t_.each($op, function (v,k) {\n\t\tensurePath(obj,k, function (t,k) {\n\t\t\tif (!t[k]) {\n\t\t\t\tt[k] = v.$each?v.$each:[v];\n\t\t\t} else {\n\t\t\t\tif (!_.isArray(t[k]))\n\t\t\t\t\tthrow new Error(\"Cannot apply $addToSet modifier to non-array\")\n\n\t\t\t\tif (v.$each) {\n\t\t\t\t\tt[k] = _.union(t[k], v.$each);\n\t\t\t\t} else {\n\t\t\t\t\tif (!_.includes(t[k],v))\n\t\t\t\t\t\tt[k].push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t})\n}\n\nfunction applyPushAll(obj,$pushAll) {\n\t_.each($pushAll, function (v,k) {\n\t\tensurePath(obj,k, function (t,k) {\n\t\t\tif (!t[k]) {\n\t\t\t\tt[k] = v;\n\t\t\t} else {\n\t\t\t\tif (!_.isArray(t[k]))\n\t\t\t\t\tthrow new Error(\"Cannot apply $push/$pushAll modifier to non-array\")\n\n\t\t\t\tt[k] = t[k].concat(v);\n\t\t\t}\n\t\t})\n\t})\n}\n\nfunction updater(op,tdb) {\n\tthis.hasAtomic = function () {\n\t\treturn _.findKey(op, function (v, k) { return k[0] === \"$\"; }) != null;\n\t}\n\n\tthis.update = function ($doc,upsert) {\n\t\tif (op.$set)\n\t\t\tapplySet($doc,op.$set);\n\t\tif (op.$unset)\n\t\t\tapplyUnset($doc,op.$unset);\n\t\tif (op.$inc)\n\t\t\tapplyInc($doc, op.$inc);\n\t\tif (op.$push)\n\t\t\tapplyPush($doc, op.$push);\n\t\tif (op.$pushAll)\n\t\t\tapplyPushAll($doc, op.$pushAll);\n\t\tif (op.$addToSet)\n\t\t\tapplyAddToSet($doc, op.$addToSet);\n\t\tif (op.$pop)\n\t\t\tapplyPop($doc, op.$pop);\n\t\tif (op.$pull)\n\t\t\tapplyPull($doc, op.$pull, tdb);\n\t\tif (op.$pullAll)\n\t\t\tapplyPullAll($doc, op.$pullAll);\n\t\tif (op.$rename)\n\t\t\tapplyRename($doc, op.$rename);\n\t\tif (upsert && op.$setOnInsert)\n\t\t\tapplySet($doc,op.$setOnInsert)\n\t}\n}\n\nmodule.exports = updater;\n","/home/travis/build/npmtest/node-npmtest-tingodb/node_modules/tingodb/lib/tdb.js":"var safe = require('safe');\nvar tcoll = require('./tcoll.js');\nvar fs = require('fs');\nvar path = require('path');\nvar _ = require('lodash');\nvar EventEmitter = require('events').EventEmitter;\n\nvar mstore = Object.create ? Object.create(null) : {};\nfunction tdb(path_, opts, gopts) {\n\tthis._gopts = gopts;\n\tthis._path = path.resolve(path_);\n\tthis._cols = Object.create ? Object.create(null) : {};\n\tthis._name = opts.name || path.basename(path_);\n\tthis._stype = gopts.memStore?\"mem\":\"fs\";\n\tif (this._stype==\"mem\")\n\t\tmstore[path_] = this._mstore = mstore[path_] || Object.create ? Object.create(null) : {};\n\t// mongodb compat variables\n\tthis.openCalled = false;\n}\n\ntdb.prototype.__proto__ = EventEmitter.prototype;\n\nmodule.exports = tdb;\n\ntdb.prototype.open = function (options, cb) {\n\t// actually do nothing for now, we are inproc\n\t// so nothing to open/close... collection will keep going on their own\n\tif (cb==null) cb = options;\n\tcb = cb || function () {};\n\tthis.openCalled = true;\n\tsafe.back(cb,null,this)\n}\n\ntdb.prototype.close = function (forceClose, cb) {\n\tvar self = this;\n\tif (cb==null) cb = forceClose;\n\tcb = cb || function () {};\n\t// stop any further operations on current collections\n\tsafe.eachOf(self._cols, function (c, k, cb) {\n\t\tc._stop(cb)\n\t}, safe.sure(cb, function () {\n\t\t// and clean list\n\t\tself._cols = Object.create ? Object.create(null) : {};\n\t\tthis.openCalled = false;\n\t\tsafe.back(cb,null,this);\n\t}))\n}\n\ntdb.prototype.createIndex = _.rest(function (c, args) {\n\tc = this._cols[c];\n\n\tif (!c)\n\t\treturn safe.back(args[args.length - 1], new Error(\"Collection doesn't exists\"));\n\n\tc.createIndex.apply(c, args);\n});\n\ntdb.prototype.collection = function (cname, opts, cb) {\n\treturn this._collection(cname, opts,false, cb)\n}\n\ntdb.prototype.createCollection = function (cname, opts, cb) {\n\treturn this._collection(cname, opts,true, cb)\n}\n\ntdb.prototype._nameCheck = function (cname) {\n\tvar err = null;\n\tif (!_.isString(cname))\n\t\terr = new Error(\"collection name must be a String\");\n\tif (!err && cname.length==0)\n\t\terr = new Error(\"collection names cannot be empty\");\n\tif (!err && cname.indexOf(\"$\")!=-1)\n\t\terr = new Error(\"collection names must not contain '$'\");\n\tif (!err) {\n\t\tvar di = cname.indexOf(\".\");\n\t\tif (di==0 || di==cname.length-1)\n\t\t\terr = new Error(\"collection names must not start or end with '.'\");\n\t}\n\tif (!err && cname.indexOf(\"..\")!=-1)\n\t\terr = new Error(\"collection names cannot be empty\");\n\treturn err;\n}\n\ntdb.prototype._collection = function (cname, opts, create, cb) {\n\tvar err = this._nameCheck(cname);\n\n\tif (!cb) {\n\t\tcb = opts;\n\t\topts = {};\n\t}\n\tcb = cb || function () {};\n\tif (err)\n\t\treturn safe.back(cb, err);\n\tvar self = this;\n\tvar c = self._cols[cname];\n\tif (c) {\n\t\tif (opts.strict && create) safe.back(cb, new Error(\"Collection \" + cname + \" already exists. Currently in safe mode.\"));\n\t\telse safe.back(cb, null, c);\n\t\treturn c;\n\t}\n\tc = new tcoll(this);\n\tself._cols[cname] = c;\n\tc.init(this, cname, opts, create, function (err) {\n\t\tif (err) {\n\t\t\tdelete self._cols[cname];\n\t\t\tcb(err);\n\t\t} else\n\t\t\tcb(null, c);\n\t});\n\treturn c;\n};\n\ntdb.prototype.collectionNames = function (opts, cb) {\n\tvar self = this;\n\tif (_.isUndefined(cb)) {\n\t\tcb = opts;\n\t\topts = {};\n\t}\n\tif (this._stype==\"mem\") {\n\t\tcb(null,_(self._mstore).keys().map(function (e) { return opts.namesOnly?e:{name:self._name+\".\"+e};}).value());\n\t} else {\n\t\tfs.readdir(self._path, safe.sure(cb,function(files) {\n\t\t\t// some collections ca be on disk and some only in memory, we need both\n\t\t\tfiles = _.union(files,_.keys(self._cols));\n\t\t\tcb(null,_(files)\n\t\t\t\t.reject(function (e) {return /^\\./.test(e);}) // ignore hidden linux alike files\n\t\t\t\t.map(function (e) { return opts.namesOnly?e:{name:self._name+\".\"+e};})\n\t\t\t\t.value());\n\t\t}));\n\t}\n};\n\ntdb.prototype.collections = function (cb) {\n\tvar self = this;\n\tself.collectionNames({namesOnly:1},safe.sure(cb, function (names) {\n\t\tsafe.forEach(names, function (cname, cb) {\n\t\t\tself.collection(cname, cb);\n\t\t},safe.sure(cb, function () {\n\t\t\tcb(null, _.values(self._cols));\n\t\t}));\n\t}));\n};\n\ntdb.prototype.dropCollection = function (cname, cb) {\n\tvar self = this;\n\tvar c = this._cols[cname];\n\tif (!c) {\n\t\tvar err = new Error(\"ns not found\");\n\t\tif (cb) return safe.back(cb, err)\n\t\t\telse throw new err;\n\t}\n\tc._stop(safe.sure(cb, function (ondisk) {\n\t\tdelete self._cols[cname];\n\t\tif (ondisk)\n\t\t\tfs.unlink(path.join(self._path,cname),safe.sure(cb, function () {\n\t\t\t\tcb(null, true)\n\t\t\t}))\n\t\telse {\n\t\t\tif (self._stype==\"mem\")\n\t\t\t\tdelete self._mstore[cname];\n\t\t\tcb(null,true);\n\t\t}\n\t}))\n}\n\ntdb.prototype.dropDatabase = function (cb) {\n\tvar self = this;\n\tself.collections(safe.sure(cb, function(collections) {\n\t\tsafe.forEach(collections, function (c, cb) {\n\t\t\tself.dropCollection(c.collectionName,cb);\n\t\t},cb);\n\t}));\n};\n\ntdb.prototype.compactDatabase = function (cb) {\n\tvar self = this;\n\tself.collections(safe.sure(cb, function(collections) {\n\t\tsafe.forEach(collections, function (c, cb) {\n\t\t\tc.compactCollection(cb);\n\t\t},cb);\n\t}));\n};\n\ntdb.prototype.renameCollection = function (on,nn,opts,cb) {\n\tif (cb==null) {\n\t\tcb = opts;\n\t\topts = {};\n\t}\n\tcb = cb || safe.noop;\n\tvar old = this._cols[on];\n\tif (old)\n\t\told.rename(nn, {}, cb)\n\telse\n\t\tsafe.back(cb);\n}\n\ntdb.prototype._cloneDeep = function (obj) {\n\tvar self = this;\n\treturn _.cloneDeepWith(obj, function (c) {\n\t\tif (c instanceof self.ObjectID)\n\t\t\treturn new c.constructor(c.toString());\n\t\tif (c instanceof self.Binary)\n\t\t\treturn new c.constructor(new Buffer(c.value(true)));\n\t});\n};\n"}